<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>插秧哥&#39;s Blog</title>
  
  <subtitle>Never Stop Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chayangge.com/"/>
  <updated>2018-12-28T09:36:24.000Z</updated>
  <id>http://chayangge.com/</id>
  
  <author>
    <name>插秧哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔尖下的深刻——村上春树</title>
    <link href="http://chayangge.com/2018/12/28/%E7%AC%94%E5%B0%96%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%88%BB%E2%80%94%E2%80%94%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    <id>http://chayangge.com/2018/12/28/笔尖下的深刻——村上春树/</id>
    <published>2018-12-28T08:57:33.000Z</published>
    <updated>2018-12-28T09:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章太美，忍不住挂在博客上：<br><a id="more"></a></p><hr><p>每一个人都有属于自己的一片森林，迷失的人迷失了，相逢的人会再相逢。</p><p>如果我爱你，而你也正巧的爱我。你头发乱了时候，我会笑笑的替你拨一波，然后，手还留恋的在你发上多待几秒。但是，如果我爱你，而你不巧的不爱我。你头发乱了，我只会轻轻的告诉你，你头发乱了喔。这大概是最纯粹的爱情观，如若相爱，便携手到老;如若错过，便护他安好。</p><p>尽管世界上有那般广阔的空间，而容纳你的空间——虽然只需一点点——却无处可寻。</p><p>于是我关闭我的语言，关闭我的心，深沉的悲哀是连眼泪这形式都无法采取的东西。</p><p>你要做一个不动声色的大人了。不准情绪化，不准偷偷想念，不准回头看。去过自己另外的生活。你要听话，不是所有的鱼都会生活在同一片海里。</p><p>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老。</p><p>试着这样想：我们每一个人，都或多或少地，是一枚鸡蛋。我们每一个人都是一个独特的、不可替代的灵魂，而这灵魂覆盖着一个脆弱的外壳。这就是我自己的真相，而且这也是你们每一个人的真相。</p><p>不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢的怎么也长久不了。</p><p>每一次，当他伤害我时，我会用过去那些美好的回忆来原谅他，然而，再美好的回忆也有用完的一天，到了最后只剩下回忆的残骸，一切都变成了折磨，也许我的确是从来不认识他。</p><p>这是个无情的世界，因为有希望的地方就必定有磨炼。</p><p>孤独一人也没关系，只要能发自内心地爱着一个人，人生就会有救。哪怕不能和他生活在一起。</p><p>人，人生，在本质上是孤独的，无奈的。所以需要与人交往，以求相互理解。然而相互理解果真可能吗?不，不可能，宿命式的不可能，寻求理解的努力是徒劳的。与其勉强通过交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈!</p><p>世界上有什么不会失去的东西吗？我相信有，你也最好相信。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章太美，忍不住挂在博客上：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack loader</title>
    <link href="http://chayangge.com/2018/12/24/webpack%20loader/"/>
    <id>http://chayangge.com/2018/12/24/webpack loader/</id>
    <published>2018-12-23T17:36:34.000Z</published>
    <updated>2018-12-23T17:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先熟悉loader"><a href="#先熟悉loader" class="headerlink" title="先熟悉loader"></a>先熟悉loader</h3><p>webpack只能处理js，对于非js的文件需要对应的loader转换成webpack能处理的模块，在进行打包，如JSX、TS、less等。</p><p>loader本质上是一个function，且按照node普通模块的方式编写，既可以是本地的一个文件，也可以打成一个npm包（项目中都是npm）。function用参数传入代码，然后按转换代码，最后输出代码。</p><h3 id="loader基本用法"><a href="#loader基本用法" class="headerlink" title="loader基本用法"></a>loader基本用法</h3><p>官方是使用方法这里过多介绍，只说明一下自己开发的本地loader使用方式，下面自己实现处理less的两个常用loader，分别为’style-loader’, ‘less-loader’，后者翻译less，前者把翻译后的css插入前端代码中。</p><p>在webpack.config.js中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">    output: &#123; // webpack打包后出口文件</span><br><span class="line">        filename: &apos;build.js&apos;, // 打包后js文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;) // 打包后自动输出目录</span><br><span class="line">    &#125;,</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        // 定义自己的loader位置</span><br><span class="line">        modules: [path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        // loader 默认从右向左、从下往上执行，可用enforce：‘pre’ normal,inlineLoader,post设定最先执行</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&apos;style-loader&apos;, &apos;less-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如上所示，用resolveLoader定义了loader的读取位置为本地的loaders文件夹，下面在该文件夹中定义这两个laoder的js文件，先以less-loader为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    // 这里处理source</span><br><span class="line">    console.log(&apos;我是自定义loader&apos;);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>此时运行webpack，会执行此loader并打印:’我是自定义loader。</p><p>loader作为一个流水线上的某个处理环节，传入了内容（String或Buffer），处理内容，最后输出内容，且输出作为下一个loader的输入，下面加入处理程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let less = require(&apos;less&apos;);</span><br><span class="line">function loader (source) &#123;</span><br><span class="line">    console.log(&apos;run loader...222&apos;, source);</span><br><span class="line">    console.log(&apos;this:&apos;, this);</span><br><span class="line">    let css;</span><br><span class="line">    less.render(source, function (error, output) &#123;</span><br><span class="line">        css = output.css;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;我是翻译后的css:&apos;, css);</span><br><span class="line">    return css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>至此，一个最基本的less文件loader就已经实现。</p><p>下面是style-loader，其作用是把css代码按最基础的方式插入页面中，所谓最基础的方式就是把css代码拼到style标签中，单后插入head标签里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>运行webpack –mode development，会看到输出结果，并在dist目录中的未压缩build.js中看到具体的css代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***/ &apos;./src/index.js&apos;:</span><br><span class="line">    /*! **********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports, __webpack_require__) &#123;</span><br><span class="line">        __webpack_require__(/*! ./index.less */ &apos;./src/index.less&apos;);</span><br><span class="line">        document.querySelector(&apos;#root&apos;).innerHTML = &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;;</span><br><span class="line">        /***/ &#125;,</span><br><span class="line"></span><br><span class="line">    /***/ &apos;./src/index.less&apos;:</span><br><span class="line">    /*! ************************!*\</span><br><span class="line">  !*** ./src/index.less ***!</span><br><span class="line">  \************************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports) &#123;</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = &apos;h1 &#123;\n  color: red;\n&#125;\n&apos;;</span><br><span class="line">        document.head.appendChild(style);</span><br><span class="line">        /***/ &#125;</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>在浏览器打开，将看到红色的hello word，说明两个loader已经正常运行。</p><h3 id="pitch"><a href="#pitch" class="headerlink" title="pitch"></a>pitch</h3><p>每个loader的function都有pitch属性方法，虽然loader的执行方式是从右向左，总下往上，但每个loader的pich是按常规顺序执行的，可以在某个laoder中打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">loader.pitch = function () &#123;</span><br><span class="line">    console.log(&apos;我是less-loader的pitch，我先执行&apos;);</span><br><span class="line">    //return &apos;source&apos; 一旦return，后续的loader将不执行</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure><p>当pitch中有return时，不在执行后面的loader，pitch在内部是以递归方式执行，当递归到底时，再执行loader，类似于koa中间件的洋葱模型，或理解为先入后出的栈模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- style-loader `pitch`</span><br><span class="line">  |- less-loader `pitch`</span><br><span class="line">    // 递归到底</span><br><span class="line">  |- less-loader normal execution</span><br><span class="line">|- style-loader normal execution</span><br></pre></td></tr></table></figure></p><p>上面所写的两个loader过于简单，未涉及loader中的this，在每一个loader的上下文中都能通过this获取到loader的相关API，应对更多的功能场景，关于更多this上的API见<a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先熟悉loader&quot;&gt;&lt;a href=&quot;#先熟悉loader&quot; class=&quot;headerlink&quot; title=&quot;先熟悉loader&quot;&gt;&lt;/a&gt;先熟悉loader&lt;/h3&gt;&lt;p&gt;webpack只能处理js，对于非js的文件需要对应的loader转换成webpac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://chayangge.com/2018/11/26/Promise/"/>
    <id>http://chayangge.com/2018/11/26/Promise/</id>
    <published>2018-11-25T17:52:02.000Z</published>
    <updated>2018-11-26T02:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。<br>Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。<br><a id="more"></a><br>Promise主要解决嵌套异步回调问题，退一步想，只是代码形式上的“重组”，而promise就是重组嵌套代码的盒子，这个盒子规定：把触发逻辑写在resolve里，回调都写在then里，这样的代码形式则变得优雅很多。</p><p>回调地狱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./test.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promis后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./test.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return data.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure></p><p>当然，应用广泛的Promise是有规范的，可以根据规范自己实现。规范也是人定的，甚至还可以抛弃规范去写自己心目中的代码。</p><p>如上面所说，Promise是代码形式上的“重组”工具，把触发代码和回调代码，以利于阅读和维护的方式重组，其中触发代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样理解起来，对Promise整体就有了全局的认识，接下来要实现的就是这个工具，这个工具的核心是：</p><ul><li>1.触发函数在新建Promise时先执行，并根据结果设定好是走resolve还是reject</li><li>2.then里的回调函数在触发后执行，这就意味着要先注册这些回调（resolve回调和reject的回调）</li><li>3.Promise要能链式调用，且每个链式产生的是一个全新的Promise（非jQuery中直接return this，而是return new Promise）</li></ul><p>###最小Promise<br>先实现一个最小功能的Promise，仅实现上述1，2功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>触发逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    resolve(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.then((value)=&gt;&#123;</span><br><span class="line">    console.log(&apos;执行成功：&apos;,value);</span><br><span class="line">&#125;,(value) =&gt; &#123;</span><br><span class="line">    console.log(&apos;执行失败：&apos;,value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述就是最简易的Promise，上来就先执行了resolve，然后执行了then中onResole的回调。</p><p>但在实际中Promise的触发逻辑都是异步的，比如发起请求，这里用setTimeout模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里因为触发函数是异步的，所以then优先于resolve执行，而此时的状态还是最初的PEDDING，为此，Promise要继续丰富这种情况，保证then里的代码优先注册，必须当resolve执行后，才执行then中注册的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line">    this.onResolvedCallback = [];</span><br><span class="line">    this.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">        console.log(this.onResolvedCallback.length);</span><br><span class="line">        for(var i = 0; i &lt; this.onResolvedCallback.length; i++) &#123;</span><br><span class="line">            this.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">        for(var i = 0; i &lt; this.onRejectedCallback.length; i++) &#123;</span><br><span class="line">            this.onRejectedCallback[i](error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;PENDING&apos;)&#123;</span><br><span class="line">            this.onResolvedCallback.push(onResole);</span><br><span class="line">            this.onRejectedCallback.push(onReject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>仔细对比改造前后的代码，会发现有以下核心改动点：</p><ul><li>then里当PENDING状态时分别存到onResolvedCallback和onRejectedCallback数组里，解决了上述中因异步触发函数导致缺失PENDING状态的问题</li><li>resolve或reject执行时，遍历各自的数组栈，把之前then中存进去的回调函数通通在此时执行</li></ul><p>这时候的触发函数终于可以写成常见的异步了。</p><p>下面只剩下一个问题3：then链式调用，then返回的是一个全新的Promise，需在then的三种情况下都返回一个new Promise，且新promise的输入是上一个promise的输出，也就是上一个promise中then里的回调函数执行结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。&lt;br&gt;Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UTF-8</title>
    <link href="http://chayangge.com/2018/10/30/UTF-8/"/>
    <id>http://chayangge.com/2018/10/30/UTF-8/</id>
    <published>2018-10-30T02:30:52.000Z</published>
    <updated>2018-10-30T02:30:53.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB备忘</title>
    <link href="http://chayangge.com/2018/09/17/MongoDB%E5%A4%87%E5%BF%98/"/>
    <id>http://chayangge.com/2018/09/17/MongoDB备忘/</id>
    <published>2018-09-17T06:39:30.000Z</published>
    <updated>2018-09-29T09:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：<br><a id="more"></a></p><ul><li>先登录机器</li><li>链接MongoDB：mongo 10.5.XX.XX:端口</li><li>show dbs</li><li>use 某db</li><li>show tables</li><li>db.sometable.find({‘_id’:’XX’});</li><li>db.sometable.update({条件},{$set:{key:value}},{multi:true}));</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sometable.find(&#123;&apos;url&apos;:&#123;$regex:/key/i&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;表名&apos;)</span><br></pre></td></tr></table></figure><h3 id="关闭MongoDB"><a href="#关闭MongoDB" class="headerlink" title="关闭MongoDB"></a>关闭MongoDB</h3><ul><li>先退出：mongo –port 8415（只用端口号登录）</li><li>use admin</li><li>db.shutdownServer()</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cd到MongoDB安装文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f mongod.conf</span><br></pre></td></tr></table></figure><h3 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h3><p>MongoDB数据库有多个节点时，会包含一个Primary节点和多个Secondary节点，数据先写入Primary节点，其他Secondary再从Primary中同步写入的数据，因此当连接数据库后，光标起始位置会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:PRIMARY&gt;</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:SECONDARY&gt;</span><br></pre></td></tr></table></figure></p><p>当要操作Secondary节点时，由于secondary节点默认不可读，会收到一下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">&quot;code&quot; : 13435,</span><br><span class="line">&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;</span><br></pre></td></tr></table></figure></p><p>解决办法，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></p><p>但下次连接是依然报错，若想根治，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.mongorc.js</span><br><span class="line"></span><br><span class="line">增加:rs.slaveOk();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://chayangge.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手与SYN Flood攻击</title>
    <link href="http://chayangge.com/2018/09/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8ESYN-Flood%E6%94%BB%E5%87%BB/"/>
    <id>http://chayangge.com/2018/09/08/TCP三次握手与SYN-Flood攻击/</id>
    <published>2018-09-08T08:08:07.000Z</published>
    <updated>2018-10-30T02:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>三次握手大家都耳熟能详了：</p><ul><li>客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应</li><li>服务端收到信号，返回SYN+ACK（Synchronization-Acknowledgement）信号，声明做好接收消息的准备，并要求客户端也要做好接收消息的准备，然后进入SYN_RCVD状态，也就是半开状态，服务端会持续等待客户端再次发起的确认信息，这个等待时间很长，能达到分钟级别。（注意：这里是攻击的核心点）</li><li>客户端收到消息后，再次发送ACK(Acknowledgement)消息给服务端，声明做好了接收数据的准备</li><li>连接成功</li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><p>因为通信双方要互相告知自己的Sequence Numbers，这个序号将作为后续通讯的数字信号，TCP会议这个序号来拼接数据，以保证数据段的顺序。相当于两人如果发生转账，必须要先知到彼此的账号一样。</p><p>其次，三次是满足一个完整、妥善会话的最小逻辑单元，比如：</p><ul><li>A:我账号是001，求汇款500元？</li><li>B:可以，我的账号002，已向你转账500。</li><li>A:好的，收到！</li></ul><p>中间任何一步的失败都会造成会话的不完整，要么A不能确认B是否转账，要么B不能确认A是否收到汇款。</p><h3 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h3><p>如上所述，B转账后会处于半开放状态，要持续等待两分钟，直到收到A的确认收到汇款消息为止。等待是焦急的，劳神的，是耗费脑细胞的。当成千上万的虚假客户端只发送握手信号SYN，收到服务端信号后，并不再次发起确认信号时，服务端则会占用大量的系统内存来维持等待这些半开放的连接，耗尽系统资源，导致正常的握手请求得不到响应，这就是SYN Flood攻击的原理。</p><h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><ul><li>缩短SYN Timeout时间</li><li>提高半开状态数量</li><li>SYN cookie：<blockquote><p>服务端收到握手信号SYN，在返回SYN+ACK时对ACK进行加密，加密信息包含原地址、端口、目标地址，总之能标识是谁发来的信息，然后不进入半开放状态，直接释放所以状态，这样省去了维持等待所耗费的系统资源，当收到客户端字再次发起的ACK信号时，计算是否为上个SYN+ACK消息的返回，如果是则直接进入连接状态。</p></blockquote></li><li>Firewalls and Proxies：<blockquote><p>用防火墙作为客户端和服务端的中间代理，客户端先与防火墙建立三次握手，只有在握手成功后，防火墙再与服务端建立握手，然后防火墙在中间代理数据传输。此时服务端收到的都是正常握手请求。</p></blockquote></li></ul><p>参考：<a href="https://www.wikiwand.com/en/SYN_flood#" target="_blank" rel="noopener">https://www.wikiwand.com/en/SYN_flood#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;三次握手大家都耳熟能详了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应&lt;/li&gt;
&lt;li&gt;服务端收到信号，返回SYN+A
      
    
    </summary>
    
    
      <category term="TCP" scheme="http://chayangge.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://chayangge.com/2018/08/13/Base64/"/>
    <id>http://chayangge.com/2018/08/13/Base64/</id>
    <published>2018-08-12T16:03:30.000Z</published>
    <updated>2018-08-12T16:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。</p><h3 id="为什么会有Base64？"><a href="#为什么会有Base64？" class="headerlink" title="为什么会有Base64？"></a>为什么会有Base64？</h3><p>Base64加密后的信息理论上会比原信息大三分之一左右，数据变大是不利于传输的，那什么优势让它依然被使用呢？</p><p>答案是因为早期的邮件传输协议SMTP只能传输可打印的ASCII码，那不支持传输的ASCII码只能换一种编码方式，用可传输的ASCII码部分来表示信息。</p><h3 id="用了哪些字符码"><a href="#用了哪些字符码" class="headerlink" title="用了哪些字符码"></a>用了哪些字符码</h3><p>虽然名叫base64，但实际用了65个字符，因为尾部用“=”表示结束，首先从0开始，到51位分别为大小写的字母a-z，52至61为数字0-9，另外加两个字符+/，正好64。<br>所以一个标准的base64编码数据就是大小写混合夹杂数字偶尔出现+/，结尾还会有“=”。</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>转换规则如下：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/base64.png" alt="转换规则"></p><p>直接看字母的二进制数据，base64把原本的8Bit一组的数据从新按6Bit一组，然后把这新的6位二进制转换成十进制，再从10进制中找到对应的字符，组成了base64的编码。这样，无论什么数据，都能用上述64个字符表达出来，而这64个字符在所有的协议中都能顺利传输。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>base64以增加传输数据变大为代价，换取了传输的兼容性，然后仅仅在肉眼上实现了‘加密’。</p><p>前端接触最多的应用场景是用于表达图片二进制信息，把不是很大的图片用base64标识，直接放在html或css中，省去浏览器再发一个资源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。&lt;/p&gt;
&lt;h3 id=&quot;为什么会有Base64？&quot;&gt;&lt;a href=&quot;#为什么会有Base64？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有Base64？&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>天！居然断更了这么久</title>
    <link href="http://chayangge.com/2018/08/12/%E5%A4%A9%EF%BC%81%E5%B1%85%E7%84%B6%E6%96%AD%E6%9B%B4%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85/"/>
    <id>http://chayangge.com/2018/08/12/天！居然断更了这么久/</id>
    <published>2018-08-12T06:31:05.000Z</published>
    <updated>2018-08-11T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>天！居然断更了这么久，</p><p>换了份工作，</p><p>把博客落下了，</p><p>适应工作节奏后，</p><p>总感觉时间不够用，</p><p>博客就：拖…</p><p>然后，服务器又到期了，</p><p>要不要买服务器呢？买哪家？</p><p>拖…</p><p>终于又买了服务器，</p><p>换了腾讯云，</p><p>可，备案居然要重新审核，</p><p>拖…</p><p>备案终于过了，</p><p>然而，本地博客跑不起来了，</p><p>还得修，</p><p>拖…</p><p>重装了博客、改了配置、再绑域名、装git、装nginx、nginx.config 等一系列操作，</p><p>终于完成了，</p><p>总耗时接近一年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天！居然断更了这么久，&lt;/p&gt;
&lt;p&gt;换了份工作，&lt;/p&gt;
&lt;p&gt;把博客落下了，&lt;/p&gt;
&lt;p&gt;适应工作节奏后，&lt;/p&gt;
&lt;p&gt;总感觉时间不够用，&lt;/p&gt;
&lt;p&gt;博客就：拖…&lt;/p&gt;
&lt;p&gt;然后，服务器又到期了，&lt;/p&gt;
&lt;p&gt;要不要买服务器呢？买哪家？&lt;/p&gt;
&lt;p&gt;拖…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://chayangge.com/2017/08/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://chayangge.com/2017/08/21/中间件/</id>
    <published>2017-08-21T03:56:16.000Z</published>
    <updated>2017-09-04T02:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。<br><a id="more"></a><br>业界有句名言：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>“Any problem  in computer science can be solved by anther layer of indirection.”</p></blockquote><p>仔细想一下很多问题都是通过添加独立的层的概念来解决的，包括一些已经作为常识的知识，比如：互联网层的划分，从底层的物理层，到上层的应用层，彼此层之间相互独立，各司其职，以后再有什么升级或改动，保证原有层不变的基础上，添加一个层承上启下，即可。比如HTTPS就是在HTTP的基础上多了一层加密层。</p><p>而中间件的概念貌似也是如此。一个中间件就是一个功能层，相互独立，各司其职。</p><p>以express中间件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listen 3000...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(middleware1);</span><br><span class="line">app.use(middleware2);</span><br><span class="line">app.use(middleware3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3，out"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.use方法用来接收中间件1、2、3，其执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listen 3000...</span><br><span class="line">我是1</span><br><span class="line">我是2</span><br><span class="line">我是3</span><br><span class="line">我是3，out</span><br><span class="line">我是2，out</span><br><span class="line">我是1，out</span><br></pre></td></tr></table></figure></p><p>为什么遇到next后就直接跳转，等所有next执行完毕才回溯执行各自next后面的代码呢？app.use内部又是怎么回事呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从结果可以看出，多个中间件的执行顺序是按栈结构执行的，首先遇到next跳转到下一个中间件执行，直到最内部的中间值执行完毕后，才执行最内部中间件next后面的代码，执行完后才返回上一层执行上一层中间件next后面的代码，像极了洋葱图。</p><p>而在代码层面上，每当调用app.use添加中间件时，其实内部维护了一个数组，把这些追加的中间件push进去，然后反方向执行，先执行数组最末端的中间件，直到第一个push进去的中间件，这样就实现了上述中间件调用效果。demo：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>关于cookie</title>
    <link href="http://chayangge.com/2017/07/26/%E5%85%B3%E4%BA%8Ecookie/"/>
    <id>http://chayangge.com/2017/07/26/关于cookie/</id>
    <published>2017-07-26T11:02:08.000Z</published>
    <updated>2017-08-05T07:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。<br><a id="more"></a><br>大家都知道http是无状态的，也就是说在一个没有cookie技术的纯请求中，服务器分不清谁请求了，以及这次请求和上次什么关系，这导致无法标识是否登录，等等所有常规功能。如果说互联网是个随进随出的商场的话，那么cookie则相当于每个请求的帽子，这个帽子标识了每个请求的身份，且这个帽子服务器可以种植，客户端（浏览器）也可以种植。</p><h2 id="cookie的样子"><a href="#cookie的样子" class="headerlink" title="cookie的样子"></a>cookie的样子</h2><p>cookie是一段文本，之所以在浏览器中看到呈现key、value的形式，是因为保存的这段文本中是以“=”和“;”隔开的，浏览器调试工具下输入<code>documen.cookie</code>就能看到。</p><h2 id="cookie的种植"><a href="#cookie的种植" class="headerlink" title="cookie的种植"></a>cookie的种植</h2><p>上文说道，cookie的种植有两种方式，服务端和客户端，服务器返回请求内容的时候用Set-Cookie在客户端下种植cookie，也可以用浏览器的方式js手动种植，比如：documen.cookie = “key = value”;一旦cookie种植后，因同源策略，在同源下的所有请求都会带上cookie，从浏览器的开发者工具中查看：</p><p>有一点需要注意，浏览器js有个属相不能设置，那就是<code>HttpOnly 属性</code>，服务端设置HttpOnly属性后，在浏览器通过documen.cookie则不能读取cookie，相对来说增加了一层安全性，提高了破解难度，但也不是万能的。</p><h2 id="cookie存在哪？"><a href="#cookie存在哪？" class="headerlink" title="cookie存在哪？"></a>cookie存在哪？</h2><p>cookie是一段文本，并存在本地，那具体在哪里呢？<br>chrome是放在：<code>~/Library/Application\ Support/Google/Chrome/Default/Cookies</code>目录下，火狐则放在<code>~/Library/Application\ Support/Firefox/Profiles/t22mmcz1.default/cookies.sqlite</code>目录下，这些都是肉眼可看到的实实在在的文本，没什么神秘感。</p><h2 id="cookie常用的属性"><a href="#cookie常用的属性" class="headerlink" title="cookie常用的属性"></a>cookie常用的属性</h2><ul><li>expires：设置cookie的过期时间</li><li>domain：指定 cookie 将要被发送至哪个或哪些域中</li><li>path：指定了请求的资源 URL 中必须存在指定的路径时，才会带相应cookie</li><li>secure：是否要求https</li><li>HttpOnly：告知浏览器该 cookie 不能通过 JavaScript 的document.cookie访问</li></ul><h2 id="cookie的容量"><a href="#cookie的容量" class="headerlink" title="cookie的容量"></a>cookie的容量</h2><p>既然cookie能携带信息，那到底能携带多少呢？官方给出的标准是4096，但实际情况则要看浏览器了，重要的是每人会愿意在cookie上携带大量信息，因为cookie每次请求都会默认带上，如果很大，则增加了请求开销。</p><h2 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h2><p>ajax请求有同源策略，cookie也要，一个cookie又要起对应生效的域名地址，仅在本域名下才能生效，</p><h2 id="同源策略导致的问题"><a href="#同源策略导致的问题" class="headerlink" title="同源策略导致的问题"></a>同源策略导致的问题</h2><p>印绶同源策略，导致cookie不能共享，但一个大公司下的各个平台往往需要靠二级域名来区分，但对用户来说，一个账号要登录所有平台，这就导致一个问题，每个二级域名的子系统下都要登录一次？那用户岂不要疯掉，比如，你登录的新浪邮箱，当你进去微博时，提示你请登录，当你进入新浪博客时再提醒你登录。。。。，那该怎么解决该问题呢？</p><h2 id="单点登录-SSO（Single-Sign-On）"><a href="#单点登录-SSO（Single-Sign-On）" class="headerlink" title="单点登录 SSO（Single Sign On）"></a>单点登录 SSO（Single Sign On）</h2><p>单店登录解决了上述问题，用户只需在一个子系统处登录，则全站任何子系统都不用再重新登录，具体原理是：建立独立的认证中心SSO server，认证中心独立于各个站点，用来统一验证并管理登录，具体不走如下：</p><ul><li>用户在站点A输入用户名和密码点击登录 站点A将用户名和密码转发给认证中心进行认证，认证中心返回Token</li><li>站点A将当前登录用户和Token存入Session(或Cookie) 在站点A上点击连接访问站点B，通过URL参数方式，将Token带给站点B </li><li>站点B将Token转交到认证中心，认证正确，返回当前用户名。 站点B将当前登录用户和Token存入Session(或Cookie)</li><li>完成登录流程</li></ul><h2 id="cookie的安全问题"><a href="#cookie的安全问题" class="headerlink" title="cookie的安全问题"></a>cookie的安全问题</h2><p>既然在请求中用cookie标志了用户，那么如果劫持获取了cookie，就能伪造真实用户做出假冒行为，常见的攻击比如：<br>CSRF:跨站请求伪造(英语:Cross-site request forgery)，通常缩写为 CSRF 或者 XSRF， 是 种冒充 户发起请求(在 户 知情的情况下),完成 些违背 户意愿的请求(如恶意发 帖，删帖，改密码，发邮件等)。</p><p>之前文章中介绍的爬虫，在爬取需要登录的页面信息时，其实也是借用别的cookie发送的请求，和CSRF的原理是一样的。</p><p>注明的Apache服务器曾经就有一个有关cookie的漏洞，具体如下：</p><blockquote><p>Apache服务器2.2.0-2.2.21版本存在一个漏洞（CVE-2012-0053），攻击者可通过给网站植入超大的Cookie，使得HTTP头超过apache的LimitRequestFieldSize（最大请求长度）4192字节，apache便会返回400错误，状态页中就包含了http-only保护的cookies。</p></blockquote><p>简单的说就是：Apache服务器咋就cookie过多时，返回的报错信息中包含了http-only。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>简单实现双向数据绑定</title>
    <link href="http://chayangge.com/2017/04/24/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://chayangge.com/2017/04/24/简单实现双向数据绑定/</id>
    <published>2017-04-24T12:26:18.000Z</published>
    <updated>2017-04-25T02:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。<br><a id="more"></a><br>实现双向绑定的方法有三种：</p><ul><li>发布/订阅模式，比如 backbone</li><li>脏检查，比如angular，（现在angular啥样就不知道了）</li><li>以Vue为代表的数据劫持 （基于Object.defineProperty()，缺陷：IE8不支持）</li></ul><p>这里就用Object.defineProperty()来实现一个小demo，哪怕IE8不支持，但也会消亡，对此不用过于care。<br>先看html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind</span>=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imgsrc"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sayHi"</span>&gt;</span>sayHi()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先要解析html里id为app的节点内容，有v-model，v-bind，v-on，解析这些命令，得出相应的操作，解析这些节点属性用到最基本的DOM属性获取操作：childNodes、attributes。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  模板解析</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line">    <span class="keyword">var</span> nodes = app.childNodes;</span><br><span class="line">    [].slice.call(nodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">        search(ele); <span class="comment">// 这里要挨个遍历并解析app里的节点</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模板就这样，机上绑定数据，就要有相关数据和函数供模板绑定，我们使用Vue初始化实例的时候都要有data，methods等参数，这里同样也需要data和绑定函数methods，为了方便，这里就定义为$data和funs：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funs = &#123;</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi..."</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    test:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $data = &#123;</span><br><span class="line">    imgsrc:<span class="string">"https://img6.bdstatic.com/img/image/smallpic/h1.jpg"</span>,</span><br><span class="line">    value:<span class="string">"123abc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎样解析模板呢？命令提取而已，无非先去除DOM上的所有属性，从中挑出有价值的，比如以v-打头的，挑出后把带有v-打头属性的节点替换一下文本内容或添加相应的监听函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> atts = node.attributes;</span><br><span class="line">    <span class="keyword">if</span>(atts)&#123;</span><br><span class="line">        [].slice.call(atts).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name,</span><br><span class="line">                attrValue = attr.value,</span><br><span class="line">                active = attrName.substring(<span class="number">2</span>),</span><br><span class="line">                activeName = attrName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(attrName.indexOf(<span class="string">"v-"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dataMap[attrValue])&#123;</span><br><span class="line">                dataMap[attrValue].push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(attr.name.indexOf(<span class="string">"on"</span>)!== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.addEventListener(activeName,funs[attr.value],<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析 bind  v-bind:src="XXXX"</span></span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"bind"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(activeName)&#123;</span><br><span class="line">                    node.setAttribute(activeName,$data[attrValue]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.innerHTML = $data[attrValue];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"model"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.value = $data[attrValue];</span><br><span class="line">                <span class="comment">// 这是input标签双向绑定的重点</span></span><br><span class="line">                node.addEventListener(<span class="string">"input"</span>,bindInput,<span class="literal">false</span>);                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">bindInput</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                node.value = $data[attrValue] = event.target.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，到这里已经完成了对模板的初始化解析，该替换的替换，该监听的事件函数也都能添加了，但这是静态的，也就是说，只能第一次绑定data，data变动怎么办呢？这里就要用到Object.defineProperty()，该属性是ES5中的，是个好东西，没有它就没有Vue，不熟悉的可以了解一下，这里不做介绍。总之数据data变动时，会触发set操作，因此在set发生时，说明数据更新了，即可更新模板，原理就这么简单，但我们首先要做的是实现对$data的每一项进行监听，遍历一遍即可，碰到对象则递归再遍历：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    observe(val); <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val === newValue)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"老的："</span>, val, <span class="string">"变新的：--》"</span>, newValue);</span><br><span class="line">            val = newValue;</span><br><span class="line">            init(); <span class="comment">// 更新模板</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候文本框和data及p元素实现了双向数据绑定，且按钮也添加了点击事件sayHi能成功绑定执行。</p><p>至此，一个基于数据劫持的双向数据绑定demo已经完成，核心就是通过Object.defineProperty监听数据的变动，有变动则刷新模板，而模板里解析指令，并执行相应的指令或函数绑定。</p><p>但本demo运行时查看源码依然能看到写在标签元素上的指令，而vue模板源码却看不到，为什么？答案是因为vue为了增加性能，把模板节点转换成成文档碎片fragment，进行遍历加工替换等操作后，再把处理后的结果插入id为app的根DOM中，这样总体上只有一次DOM的append操作，而DOM操作是性能的杀手，vue以此提升性能，而本demo没考虑性能优化，是直接遍历替换DOM的，所以demo有很多不足，目的只为说明数据劫持实现双向数据绑定的原理，有空会再写一篇详细的作为补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。&lt;br&gt;
    
    </summary>
    
    
      <category term="mvvm" scheme="http://chayangge.com/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>公众号爬虫node版</title>
    <link href="http://chayangge.com/2017/03/28/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E8%99%ABnode%E7%89%88/"/>
    <id>http://chayangge.com/2017/03/28/公众号爬虫node版/</id>
    <published>2017-03-28T12:53:23.000Z</published>
    <updated>2017-03-29T01:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前用<a href="http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/">python实现</a>了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是<a href="https://github.com/chayangge/node-crawler" target="_blank" rel="noopener">源码</a>，数据来源<a href="http://chuansong.me/" target="_blank" rel="noopener">在这里</a>。<br><a id="more"></a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>clone并安装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/chayangge/node-crawler.git</span></span><br><span class="line">cd node-crawler</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app</span><br></pre></td></tr></table></figure></p><p>会在项目根目录下创建以微信ID命名的文件夹，里面存放抓取后的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用&lt;a href=&quot;http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/&quot;&gt;python实现&lt;/a&gt;了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是&lt;a href=&quot;https://github.com/chayangge/node-crawler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;，数据来源&lt;a href=&quot;http://chuansong.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>python的GIL</title>
    <link href="http://chayangge.com/2017/03/28/python%E7%9A%84GIL/"/>
    <id>http://chayangge.com/2017/03/28/python的GIL/</id>
    <published>2017-03-28T01:58:35.000Z</published>
    <updated>2017-03-28T07:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天用Python写爬虫，想用多线程写一个能充分调用CPU的高效爬虫，毕竟和js相比，Python天生支持多线程、多进程的，不像js的单线程，一次之能执行一个任务。结果无意间发现了Python的GIL，了解GIL首先要理解一下概念：线程与进程，并行与并发，单核与多核。<br><a id="more"></a></p><h2 id="线程与进程、单核与多核、并行与并发"><a href="#线程与进程、单核与多核、并行与并发" class="headerlink" title="线程与进程、单核与多核、并行与并发"></a>线程与进程、单核与多核、并行与并发</h2><p>线程是进程的子集，也就是一个进程至少包含一个线程，计算机每处理一个任务就是处理一个进程，该进程可能包含了多个线程，比如执行人执行一个跳跃动作（线程），这个动作就是由多个线程完成的，包括膝盖弯曲，脚踝发力，手臂摆动等多个组合动作。</p><p>现在的CPU都是多核了，基本上是4-8核，双核的都少了，多核相当于多个CPU。在古老的年代，CPU处理能力很低，一个单核CPU同时只能执行一个任务（虽然现在也是），这导致听歌只能听歌，播放视频只能播放视频，如果要读写文件CPU必须等着啥也不干，直到文件读取完毕才能计算，这显然不可取，所以目前操作系统采用了以下两个处理方案：</p><ul><li>每个任务都只执行一会，然后切换到其他任务（分时系统）</li><li>每个任务分配优先级权限，操作系统可强制安排优先的任务执行（抢占式）</li></ul><p>所以这形成了多任务完美『并行』的假象（即可听歌、看电影、又可同时敲代码），然而对单核CPU来说这其实是并发：多个任务同时存在，但轮流执行，同一时间只执行一个。想要并行？除非有多个CPU，也就是现在常见的多核CPU。</p><h2 id="Python的多线程与多进程"><a href="#Python的多线程与多进程" class="headerlink" title="Python的多线程与多进程"></a>Python的多线程与多进程</h2><p>以上说了这么多都是操作系统的基本知识，很多语言都能调用系统以多进程，多线程的方式运行，这里排除js，因为js天生单线程，而Python不是，即可多线程又可多进程。如果想让python爬虫执行的更快，可以：</p><ul><li>开启多线程</li><li>开启多进程</li><li>多进程下再开启多线程<br>理论上很完美，但实际上，你会碰到GIL，这个天生的紧箍咒把Python这匹千里马压制的普普通通。</li></ul><p>执行以下代码，在mac的活动监视器中查看CPU利用率：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x = x ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p><p>上述代码启用了CPU的所有内核一起死循环，按理说每个核该跑满了显示100%，我的是4核，此时监视器应该显示400%，可实际上却显示160%，这说明CPU并没有因Python启用了多线程而充分调度起来。</p><p>语言的编译需要解释器，Python官方的解释器是CPython，也是目前用的最多的解释器，而GIL就存在CPython中，所以Python语言的指的就是CPython中的GIL（Global Interpreter Lock）即全局解释器锁。</p><p>当Python以多线程运行时，本以为可以效率翻倍，然而现实情况是：每个线程在执行前需要获得全局GIL锁才可，线程再多可GIL锁只有一个，一个线程拿到锁，运行100条字节码后必须把锁交出来，让别的线程运行一会——像不像CPU的分时系统？表面是多线程一起执行，实际上是用快速切换的方式，每个执行一会，造成一起执行的假象。</p><p>所以上述代码之所以只用全部CPU的160%，是因为受到了GIL锁的限制。</p><h2 id="有弊就有利"><a href="#有弊就有利" class="headerlink" title="有弊就有利"></a>有弊就有利</h2><p>如果一味抨击GIL的话也是不公平的，如果GIL是万恶的源头的话那么想一想：</p><ul><li>毕竟也有不带GIL的Python解释器，可为什么那些解释器没有被广泛使用呢？</li><li>如果是早期历史遗留问题，为什么Python3 依然没有摘除GIL呢？</li></ul><p>多线程是否真的完美呢？单线程真的很慢吗？并不一定。线程的却换运行需要切换线程上下文，这自然也是一笔开销，CPU忙于多线程的切换工作导致线程运行效率降低，有时反而低于单线程。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>GIL限制了多线程，也就是说GIL针对的是一个进程下的多线程，如果启用多进程呢？进城之间相互独立，也没有『进程锁』的东西，貌似可以，这也是multiprocessing的由来，用multiprocessing创建的多进程再也没有GIL的限制，就能充分利用多核CPU的性能。除此之外还有c语言扩展机制、ctypes等方法，这些没做研究，不敢瞎写。</p><h2 id="单线程的优势"><a href="#单线程的优势" class="headerlink" title="单线程的优势"></a>单线程的优势</h2><p>单线程自然有单线程的优势和应用场景，比如单线程的程序状态单一稳定，没有通信、锁等问题，也不用来回切换上下文，更好的提高CPU使用率。除此之外Nginx、nodeJS、PHP也都是单线程，但针对单线程的弊端也都有优化机制，比如nodeJS的child_process模块。</p><p>总之这是一个取舍问题，根据自己的业务环境，总有适合的技术方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天用Python写爬虫，想用多线程写一个能充分调用CPU的高效爬虫，毕竟和js相比，Python天生支持多线程、多进程的，不像js的单线程，一次之能执行一个任务。结果无意间发现了Python的GIL，了解GIL首先要理解一下概念：线程与进程，并行与并发，单核与多核。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://chayangge.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用python抓取公众号所有文章</title>
    <link href="http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    <id>http://chayangge.com/2017/03/22/用python抓取公众号文章/</id>
    <published>2017-03-22T10:14:26.000Z</published>
    <updated>2017-03-28T13:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我初学IT的时候，『网络爬虫』是个高大上的词汇，感觉『爬虫自动抓取』简直就是神一样的技术，不明觉厉，想到自己这么菜肯定学不会，后来了解<code>http</code>，猛然发现所谓网络爬虫本质上就是一个下载器而已。<br><a id="more"></a><br>为了消除爬虫的神秘感，重要的事情说三遍：爬虫就是一个下载器，一个下载器，下载器…</p><h2 id="那什么是下载器？"><a href="#那什么是下载器？" class="headerlink" title="那什么是下载器？"></a>那什么是下载器？</h2><p>下载器就是一个能发起http请求的东西，而浏览器可以理解为一个下载器和一个显示器的合体，那么网络爬虫就是一个能发起http请求，并从请求返回内容中筛选信息的程序。所以理解一个爬虫基本要一下几个硬知识：</p><ul><li>http是无状态的，谁都可以请求，且服务器不知道你是谁和上次什么区别（纯条件下，排除cookie、session技术）</li><li>凡是能发起请求，也就是可以网络编程的语言都可以写爬虫</li><li>各种语言为爬虫封装了各种请求框架、解析工具，写一个简单的爬虫真的很简单</li></ul><h2 id="用python写一个爬虫"><a href="#用python写一个爬虫" class="headerlink" title="用python写一个爬虫"></a>用python写一个爬虫</h2><p>python是门好语言，语法简洁优雅，还能做数据分析，爬虫技术更是相当成熟，各种包满足你各种要求，之前用python抓取过某网站的图片，感觉跟给力，现在用它做一个实用点的工具——抓取公众号文章。</p><p>公众号文章只能在手机上看，且查看历史还要一直往下滚，体验上和操作上都很麻烦，作为优质的公众号，想保存所有历史文章供日后慢慢欣赏在手机上很难实现，而有的PC网站上有但靠复制粘贴保存也费时费力，所以这个爬虫或许能解决这些问题。</p><p>首先要找到公众号文章资源，搜狗搜索提供微信公众号搜索，但只能前10篇，虽然后续可以一直抓取最新，但历史文章依然无法获取，还好有个网站，收录了公众号所有文章，就是这个<a href="http://chuansong.me/" target="_blank" rel="noopener">传送门</a>。用到了如下几个包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> requests <span class="comment">##发起请求</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">##分析抓取结果</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure></p><h2 id="分析url"><a href="#分析url" class="headerlink" title="分析url"></a>分析url</h2><p>找到文章资源后就要分析页面了，我们以<a href="http://chuansong.me/account/caozsay" target="_blank" rel="noopener">caoz的梦呓</a>公众号为例，我们发现其地址信息为<code>http://chuansong.me/account/</code>+<code>公众号id</code>的形式，所以我们的爬虫要支持输入微信公众号id作为参数进行爬取:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">print</span> <span class="string">"正在搜索公众号："</span>, sys.argv[<span class="number">1</span>]</span><br><span class="line">wechat_id = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"抓取地址："</span>, <span class="string">"http://chuansong.me/account/"</span> + wechat_id</span><br></pre></td></tr></table></figure></p><h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>分析页面源码发现DOM节点清晰明了，没有后续js动态渲染，简直是爬虫的最爱：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/n/1669813351709"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">赠人玫瑰，手有余香</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/n/1663085851719"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">Google关键词挖掘细分市场实战案例</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这里说明为什么要查看源码，因为有些网站为了反爬虫，把后台数据放在js里，让前端js进行后续渲染类似前端模板的作用，这样的html源码空空如也，非常不利于抓取，但还好我们有<code>PhantomJS</code>相当于一个无界面的浏览器，依然可以搞定，这里似乎可以明白：在互联网中，几乎没什么是抓不到的，差别只在抓取难度上而已，如果难度很大，成本高，则不如自己制造数据，这样抓取就不划算了。</p><p>如上源码所示，节点清晰明了，抓取非常容易，轻轻松松获取<code>href</code>即可。至于获取方法，<code>BeautifulSoup</code>提供了非常方便的方法，如果你用过jquery的话，那更是轻松自如了，这里查看源代码即可，不过多介绍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article_list = Soup.find_all(<span class="string">'a'</span>,class_=<span class="string">"question_link"</span>)</span><br><span class="line">page_list = Soup.select(<span class="string">".w4_5 &gt; span &gt; a"</span>)</span><br></pre></td></tr></table></figure></p><p>获得了节点序列，进行遍历，把遍历出的结果写入文件保存即可，无论是抓图还是抓取文字，都是这样。</p><h2 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h2><p>再次说到http，最开始http设计的时候，在当年的互联网环境下就是为了方便简洁，因此http被设计为无状态的，对服务器来说，不知道谁请求的和上次有什么关系，然而现在不能满足需求，为此设计了cookie、session技术来进行身份识别，这些是反爬虫的技术来源之一，而爬虫获取造成的服务器负担，在法律上目前属于灰色地带，如果一个网站每天被爬虫疯狂的访问，服务器看似很繁忙，然而却没有真实用户，也是件悲伤的事。更有甚者，犹豫爬虫的疯狂请求，导致服务器变慢，影响正常使用，这就算是攻击了。</p><p>所以发爬虫也很必要，常见策略有：数据用js动态加载，增加抓取难度，限制IP，如果某个IP访问频率很高，可封锁IP，但这要注意标准，以免误伤真实用户，然而封锁IP也不能从跟上解决，因为爬虫可以通过代理不停的更换IP，总之爬虫和反爬虫就是一个博弈，背后比的是成本，时间成本，技术成本，金钱成本。</p><h2 id="如何避免反爬虫"><a href="#如何避免反爬虫" class="headerlink" title="如何避免反爬虫"></a>如何避免反爬虫</h2><p>说白了就是伪装成真实用户，比如时间上不要这么疯狂，间隔个几秒，别被服务器反爬虫盯住，其次就是不停的更换请求头<code>User-Agent</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_agent_list = [</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+"</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>这样服务器接收到请求信息就来自不同的浏览器，如果对于需要登录的网站，我们还要保存登录信息，维持cookie状态等，这里也有相应的框架和工具。</p><h2 id="爬虫优化"><a href="#爬虫优化" class="headerlink" title="爬虫优化"></a>爬虫优化</h2><p>一个能跑通的程序和可用之间还差很多细节，比如文件夹创建，保存目录，抓取提示，文件排序、代码优化等等，python并不是我的常用语言，整个实现过程也是边试边查文档，最后源代码放在<a href="https://github.com/chayangge/python-crawler" target="_blank" rel="noopener">这里</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>下载源码后，安装相应的包，执行脚本+微信id 即可，然后就就可以看到终端显示的一条条住区进度了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python crawler.py caozsay</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我初学IT的时候，『网络爬虫』是个高大上的词汇，感觉『爬虫自动抓取』简直就是神一样的技术，不明觉厉，想到自己这么菜肯定学不会，后来了解&lt;code&gt;http&lt;/code&gt;，猛然发现所谓网络爬虫本质上就是一个下载器而已。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://chayangge.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>node与mysql</title>
    <link href="http://chayangge.com/2017/03/16/node%E8%BF%9E%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://chayangge.com/2017/03/16/node连上数据库/</id>
    <published>2017-03-16T03:26:52.000Z</published>
    <updated>2017-04-25T02:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都在混迹于『前端』，虽然使用node服务器，但也是用node请求java核心接口，node后台接口只做一些边边角角的逻辑，如上传，图片识别等第三放SDK，所以node对数据库的直接操作经验为零，连sql语句都忘得差不多了，这次就做了个小demo，破除一下对未知的神秘感，<a href="https://github.com/chayangge/node-express-mysql" target="_blank" rel="noopener">源码在这</a>。<br><a id="more"></a></p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>两种安装方式，常规安装包下一步和brew安装，我自豪的采用brew<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure></p><p>这里有坑：安装完成后终端运行启动mysql命令无效，不给错误样式了，网上找了些处理方法，运行了几个命令就搞定了，具体哪个发挥了直接效果也说不好了，不太好复现问题，解决方法是（设置 MySQL 用户以及数据存放地址）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew link --overwrite mysql</span><br><span class="line">unset TMPDIR</span><br><span class="line">mysql_install_db --verbose --user=root</span><br></pre></td></tr></table></figure></p><p>启动mysql：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server <span class="keyword">start</span>  // 其他命令： &#123;<span class="keyword">start</span>|<span class="keyword">stop</span>|restart|reload|<span class="keyword">force</span>-reload|<span class="keyword">status</span>&#125;</span><br></pre></td></tr></table></figure></p><p>用户名密码登录mysql：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p><p>你也可以更改新密码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password</span><br></pre></td></tr></table></figure></p><h2 id="熟悉的sql命令"><a href="#熟悉的sql命令" class="headerlink" title="熟悉的sql命令"></a>熟悉的sql命令</h2><p>登录成功后，进入mysql命令行状态，就可以操作数据库了：<br>查看数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure></p><p>+——————–+<br>| Database           |<br>+——————–+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+——————–+</p><p>新建数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> myDB;</span><br></pre></td></tr></table></figure></p><p>myDB数据库中新建数据表user：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> myDB;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (<span class="keyword">ID</span> <span class="built_in">int</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,<span class="keyword">NAME</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,AGE <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p>查看数据表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></p><p>插入数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">"jim"</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure></p><p>查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></p><p>+—-+——+——+<br>| id | name | age  |<br>+—-+——+——+<br>|  1 | jimm |   33 |<br>+—-+——+——+<br>好，至此数据库这边已经完成，下一步开始node。</p><h2 id="假设你已安装node和express"><a href="#假设你已安装node和express" class="headerlink" title="假设你已安装node和express"></a>假设你已安装node和express</h2><p>还是用<a href="http://expressjs.com/en/starter/generator.html" target="_blank" rel="noopener">Express应用生成器</a>来创建一个完整的供成目录。</p><p>和其他平台语言一样，在工程中创建mysql通用配置文件conf.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mysql: &#123;</span><br><span class="line">        host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        user: <span class="string">'root'</span>,</span><br><span class="line">        password: <span class="string">'你的密码'</span>,</span><br><span class="line">        database: <span class="string">'myDB'</span>,</span><br><span class="line">        port: <span class="number">3306</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其次为了方便还应该创建一个增删改查的sql语言对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    insert: <span class="string">'INSERT INTO user(id, name, age) VALUES(0,?,?)'</span>,</span><br><span class="line">    update: <span class="string">'update user set name=?, age=? where id=?'</span>,</span><br><span class="line">    <span class="keyword">delete</span>: <span class="string">'delete from user where id=?'</span>,</span><br><span class="line">    queryById: <span class="string">'select * from user where id=?'</span>,</span><br><span class="line">    queryAll: <span class="string">'select * from user'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以后需要连接数据库只需require这两个文件即可，下面开始创建数据库连接，使用的npm包是mysql：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure></p><p>安装完毕可以建立数据库连接池了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"conf.js"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"sqlMap.js"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> pool = mysql.createPool(conf.mysql);</span><br><span class="line">pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, connection</span>) </span>&#123;</span><br><span class="line">    connection.query(<span class="string">"select * from user"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        res.send(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样即可获取到数据库中的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都在混迹于『前端』，虽然使用node服务器，但也是用node请求java核心接口，node后台接口只做一些边边角角的逻辑，如上传，图片识别等第三放SDK，所以node对数据库的直接操作经验为零，连sql语句都忘得差不多了，这次就做了个小demo，破除一下对未知的神秘感，&lt;a href=&quot;https://github.com/chayangge/node-express-mysql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码在这&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>从Object.prototype角度看js原型</title>
    <link href="http://chayangge.com/2017/03/08/%E4%BB%8EObject.prototype%E8%A7%92%E5%BA%A6%E7%9C%8Bjs%E5%8E%9F%E5%9E%8B/"/>
    <id>http://chayangge.com/2017/03/08/从Object.prototype角度看js原型/</id>
    <published>2017-03-08T08:16:46.000Z</published>
    <updated>2017-03-09T02:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：<br><a id="more"></a></p><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>为什么说<code>Object.prototype</code>是原型链的根？我们先把它打印出来开始：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.38.png" alt="Object.prototype"><br>可见，其原型上有几个熟悉的方法：</p><ul><li>hasOwnProperty</li><li>isPrototypeOf</li><li>toLocaleString</li><li>toString</li><li>valueOf</li></ul><p>这里方法的功能不是本文重点，这里不做介绍。只要记着Object的原型上有这几个方法就好,且<strong>留意hasOwnProperty函数，具体原因后续说明</strong>此时我们回忆下js的引用类型有以下几种：</p><ul><li>Object</li><li>Function</li><li>Number</li><li>RegExp</li><li>Date</li><li>Boolean</li></ul><p>我们知道这些引用型的实例就是我们常用的对象，函数，数值，正则，日期和布尔型数据，也就是说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>首先，我们应该都知道new出的实例会继承父对象中prototype中的方法，比如我们打印Array.prototype：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/QQ20170308-194513.png" alt="Array.prototype"><br>我们看到，数组常用的方法都能在里面找到，所以new出来的数组实例arr自然拥有上述方法。但有个<strong>奇怪的函数hasOwnProperty</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(arr.hasOwnProperty)</span><br></pre></td></tr></table></figure></p><p><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.59.png" alt="arr.hasOwnProperty"><br>Array的原型中，也就是Array.prototype中并没有hasOwnProperty。</p><h2 id="arr-hasOwnProperty从哪里来？"><a href="#arr-hasOwnProperty从哪里来？" class="headerlink" title="arr.hasOwnProperty从哪里来？"></a>arr.hasOwnProperty从哪里来？</h2><p>答案就是从js的『根』中来，也就是来自Object.prototype。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>下面这句特别重要：<br>实例arr的属性方法来自实例化它的Array的原型（Array.prototype）,那Array.prototype中的方法又来自哪里？答案是：一部分是js根据Array类型特意内置的，比如说sort方法，其余类型就没有，还有一部分就是来自根：<code>Object.prototype</code>,通过神秘的<code>__proto__</code>来实现引用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>而<code>__proto__</code>指向实例化它的对象的原型，也就是：实例化它的对象的prototype：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>那Array.prototype对象（原型也是对象）是谁实例化的呢？上面已经揭晓，既然Array.prototype中引用了Object.prototype中的方法，自然：<br>console.log(Array.prototype.<strong>proto</strong> === Object.prototype) //true<br>到这里我们几乎可以这么理解：arr的根是Array.prototype，而Array.prototype的根，也就是js的根：<code>Object.prototype</code>,<code>Object.prototype</code>上的方法自然能被层层下属使用，hasOwnProperty就是最好的说明。<br>除Array外，其余也是如此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="comment">// .......</span></span><br></pre></td></tr></table></figure></p><blockquote><p>为什么Object.prototype中有这么多方法，本文只拿hasOwnProperty来做说明，答案是因为：其余方法如toString，valueOf会根据数据类型情况而被重写，比如Date型和Boolean型的toString和valueOf就是被重写改造后的，并没用使用根中自带的，这里就不举例了。</p></blockquote><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>既然Object.prototype是根，且里面的方法可以层层被继承使用，那么这里就验证一下：<br>我们在Object.prototype上新增一个方法test：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是来自js根中的方法！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不同数据类型的实例:</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">arr.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">b.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">d.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...毫无疑问所有的实例都拥有了test方法</span></span><br></pre></td></tr></table></figure></p><p>上述大范围从根上扩充只是测试，一般情况下我们针对某一类型进行扩充足矣，比如js的trim方法只去两头空格，不包括中间空格，那么我们只需针对String类型在其原型上创建去全部空格方法allTrim即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.allTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"   aa  bb  cc   "</span>.allTrim(); <span class="comment">//aabbcc</span></span><br></pre></td></tr></table></figure></p><p>这样所有的字符串实例都有了allTrim方法，理解了js的原型，则理解了js的继承机制。</p><h2 id="一切皆空"><a href="#一切皆空" class="headerlink" title="一切皆空"></a>一切皆空</h2><p>既然Array、Function、Number的原型对象都通过<code>__proto__</code>引用自根<code>Object.prototype</code>，那么<code>Object.prototype</code>也是一个原型对象，它的根又来自哪里呢？答案是<code>null</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>null 才是js原型链的终结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://chayangge.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>收割与被收割</title>
    <link href="http://chayangge.com/2017/03/05/2017-03-05%20%E6%94%B6%E5%89%B2%E4%B8%8E%E8%A2%AB%E6%94%B6%E5%89%B2/"/>
    <id>http://chayangge.com/2017/03/05/2017-03-05 收割与被收割/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2017-03-24T10:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>人与人之间存在一种『势能』，势能高者拥有更多的资源、经验或资历。就像老师之于学生，领导之于员工…</p><p>势能低者与高者很难形成平等有效的沟通，比如：即使加了某大V的微信也很难与之成为朋友，自己也不会成为大V。</p><p>两者相遇，势能高者完全俯视低者，控制聊天话题的走向，言行轻松自如，占尽主场优势，势能低者则要被动很多，时而献媚，时而强颜欢笑。</p><p>现在火热的『粉丝经济』、『知识付费』很多就是高势能者向低势能者的一次收割。</p><p>这本是好事，增加了知识流动，让更多人收益。但一热就不好了。</p><p>总有一些假大V，迅速包装自己，凭借他人难以辨别的所谓干货、经验，招摇撞市，宣传文案读起来热血沸腾：<br>三招让你人生逆袭<br>职场升值10大策略<br>人生7大捷径<br>创业10年我总结了这些<br>未来世界5大生存法则<br>…</p><p>知识是抽象的，可以注水、可以分割，一篇干货完全可以分10篇来写，1小时的分享完全可以注水成2小时，很难保证大V是否真诚。</p><p>真诚的大V分享的往往也是他个人以为正确的事，有些结果掺杂了很多随机因素，这些随机因素可能被总结为主要因素，甚至更为荒谬。</p><p>其次，想一个问题：你会不会把自己吃饭的看家本领到处分享？那些不为认知的核心秘密估计没人会说，哪怕说了，也是挑边边角角，或外人再也没有机会效仿的、再也无法复制的『干货』——永远正确的废话。</p><p>一不小心大脑被注入了他人的草，在你的呵护下，生根发芽，茁壮成长，直到热潮过后，凌冬来临，头脑还是一片荒原，唯一的变化是：兜里的钱又少了一部分。</p><p>收割与被收割。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人与人之间存在一种『势能』，势能高者拥有更多的资源、经验或资历。就像老师之于学生，领导之于员工…&lt;/p&gt;
&lt;p&gt;势能低者与高者很难形成平等有效的沟通，比如：即使加了某大V的微信也很难与之成为朋友，自己也不会成为大V。&lt;/p&gt;
&lt;p&gt;两者相遇，势能高者完全俯视低者，控制聊天话
      
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>关于博客</title>
    <link href="http://chayangge.com/2017/03/02/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <id>http://chayangge.com/2017/03/02/关于博客/</id>
    <published>2017-03-02T06:23:03.000Z</published>
    <updated>2017-03-09T04:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>我从2014年开始写博客，到现在勉强快3年了，而真正意义上的持续写博客，主要还是后两年。现在看最开始写的文章，简直弱爆了，写的技术也很肤浅，虽然现在也不怎么深。我现在依然清晰的记得：2014年，躁动的我逼着自己写下了第一篇博客，并说要继续坚持，要习惯和键盘啪啪。那时候，脑子空洞，语言生涩——根本写不出来，就像做恶梦：想喊张不开嘴，想跑迈不开腿。<br><a id="more"></a><br>现在略有好转，但依然初级阶段。</p><p>博客经历了三个平台：CSDN，博客园，到现在的独立博客。前面两家都不错，CSDN可定制化太弱，记忆力除了换图没别的可更改的，而博客园则好了很多，从丰富的主题挑选，到自定义零部件，样式到js动作，还是比CSDN要好很多，更有主人的感觉，且博客园的管理员回复特别及时，不像某些平台好几天才给回复。但博客园首页貌似很多年没更新了，界面样式老旧，和Markdown编辑器相比，后台写作体验也不太好。</p><p>然后就有了现在的博客，目前为止已经换了三个主题了，越换越简洁，之前意淫的各种花哨主题，现在反而觉得厌恶。那些了博客零部件其实根本无用，文字就很好，字体、颜色，规规整整、简洁大方才是美，且内容为重。</p><p>独立博客与博客平台相比最大的优势就是完全自定义——这象征着自由。从域名，服务器，DNS解析…几乎没有任何限制，整个一套搭起来，能体会到很多细节和模糊的技术点。劣势可能就是需要自己推广，没有博客平台的蹭首页优势，阅读量需要自己来搞，这一点我到不太顾虑：以现在自己的技术水平，还不足以追求阅读量。</p><p>写博客是件挺辛苦的事，远比想象中耗时费力，编写边思考，有时还要重新查资料，写demo，贴代码，处理截图，还要站在新手的角度把知识点更好的表达出来…尤其是初始阶段，不仅体会不到乐趣，过程还异常坎坷，这可能导致很多人选择放弃。然而，挺过一段时间后，博客积累了一点数量，再整体看上去会好很多，有那么点成就感，不亚于农民伯伯看到自己播种的麦田，好吧，这也是起名插秧哥的一部分缘由。</p><p>偶尔才能感受到脑海里的满满思绪，偶尔才能体会到键盘的『绕指柔』，已经知足，毕竟还要继续，希望能从键盘的啪啪啪中体会更多乐趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我从2014年开始写博客，到现在勉强快3年了，而真正意义上的持续写博客，主要还是后两年。现在看最开始写的文章，简直弱爆了，写的技术也很肤浅，虽然现在也不怎么深。我现在依然清晰的记得：2014年，躁动的我逼着自己写下了第一篇博客，并说要继续坚持，要习惯和键盘啪啪。那时候，脑子空洞，语言生涩——根本写不出来，就像做恶梦：想喊张不开嘴，想跑迈不开腿。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>瞬间爱上命令行：代码提交脚本</title>
    <link href="http://chayangge.com/2017/01/24/%E7%9E%AC%E9%97%B4%E7%88%B1%E4%B8%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC/"/>
    <id>http://chayangge.com/2017/01/24/瞬间爱上命令行：代码提交脚本/</id>
    <published>2017-01-24T07:31:38.000Z</published>
    <updated>2017-05-09T09:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用git的提交代码时，步骤繁琐：先add，后commit，再push：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m "备注"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>完全可以用一个脚本减少这些重复操：<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">if [ "$1" == "" ]</span><br><span class="line">then </span><br><span class="line">set "默认提交"</span><br><span class="line">fi</span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m $1</span><br><span class="line">git push</span><br><span class="line">echo "==========提交成功=========="</span><br></pre></td></tr></table></figure></p><p>保存为cmt.sh文件放在工程下即可，但这还远远不够，因为每次提交都要在commit时做个备注，所以该脚本使用时可直接在运行命令后添加备注，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh cmt.sh 这是备注信息</span><br></pre></td></tr></table></figure></p><h2 id="这还不够"><a href="#这还不够" class="headerlink" title="这还不够"></a>这还不够</h2><p>这样方便了很多，但毕竟公司不止一个工程，难道每个项目下都要添加该脚本？当然，还有更好的办法——用alias定义成一个可全局使用的命令：<br>原理可参考这篇文章：<a href="http://chayangge.com/2016/07/18/mac%E7%BB%88%E7%AB%AF%E7%94%A8alias%E8%87%AA%E5%AE%9A%E4%B9%89shell%E5%91%BD%E4%BB%A4/">用alias自定义shell命令</a>，但这里稍有不同的是，为了维护方便，没有把alias的命令写在自己的~/.zshrc  或~/.bashrc里，而是把该脚本放在本地某个文件下，用alias指向链接即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allies  cmt='/你的脚本路径/cmt.sh'</span><br></pre></td></tr></table></figure></p><p>这样在终端直接运行命令<code>cmt</code>即可自动提交。</p><h2 id="注意（1）："><a href="#注意（1）：" class="headerlink" title="注意（1）："></a>注意（1）：</h2><p>仅仅这样执行<code>cmt</code>会提示没有权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: permission denied: /xx/xx/cmt.sh</span><br></pre></td></tr></table></figure></p><p>这是因为cmt.sh默认脚本默认是没有权限直接运行的，执行<code>ls -al</code>可看到其权限信息为：<code>-rw-r--r--</code>即自己只有读<code>r</code>(4)写<code>w</code>(2)没有执行权限<code>x</code>(1)，所以要用<code>chmod</code>命令修改权限为<code>-rwxr--r--</code>即744。所以执行命令赋予其可执行权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 cmt.sh</span><br></pre></td></tr></table></figure></p><p>这样在终端执行<code>cmt</code>可看到代码已经自动提交。</p><h2 id="注意（2）："><a href="#注意（2）：" class="headerlink" title="注意（2）："></a>注意（2）：</h2><p>如果在分支上提交失败，并提示一下信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch 分支名 has no upstream branch.</span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin 分支名</span><br></pre></td></tr></table></figure></p><p>那就执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin 分支名</span><br></pre></td></tr></table></figure></p><p>因为脚本里的push命令直接就是<code>git push</code>，而非<code>git push origin 分支名</code>，运行上述命令即可提交。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用git的提交代码时，步骤繁琐：先add，后commit，再push：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &quot;备注&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完全可以用一个脚本减少这些重复操：&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://chayangge.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>钱的诱惑</title>
    <link href="http://chayangge.com/2017/01/18/2017-01-18%20%E9%92%B1%E7%9A%84%E8%AF%B1%E6%83%91/"/>
    <id>http://chayangge.com/2017/01/18/2017-01-18 钱的诱惑/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-03-24T10:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先应该承认：钱当然能买到幸福。</p><p>小时候吸引自己的比较简单，零食，玩具，新衣。</p><p>而吸引成年人的就是钱。</p><p>踏入社会后才明白钱的意义，再也不会以花钱来换取豪爽这个虚词。</p><p>很少会为了所谓的义而贬视钱，那种“我不差这点钱，我就是咽不下这口气”云云。</p><p>哪怕豪爽了，其实背后也是为了换取另一种东西，诸如：面子，大方，敞亮。</p><p>所以那也是交易——花钱买好感。</p><p>当诚信和钱二选一的时候，合格的并不多，尤其是在暗地里。</p><p>儿时的借钱是真诚的，甚至还能借出交情来。</p><p>成人间的借钱是忌讳的，丢失金钱甚至还会丢失朋友。</p><p>收钱者拿到还款有多高兴，还款者就有多痛苦。</p><p>而讽刺的是：这笔钱本来就属于收钱者，这笔钱本来就不属于还款者。</p><p>但在感觉上一个是意外收获，一个是掉肉之痛。</p><p>可见钱的魅力。</p><p>像吸血鬼之于鲜血。</p><p>人人计较钱，却又羞于谈钱。</p><p>终于有人自信的喊出来：我是商人，我的职责就是获取更多利益。</p><p>多么干脆利落。</p><p>等同于：我是成年人，我的职责就是要挣更多的钱。</p><p>我要挣更多的钱让自己幸福，然后让家人幸福，最后最后让身边的其他人幸福。</p><p>不偷不抢，不踩红线，还能信守承诺，这已经是上乘。</p><p>警惕那些张口闭口就是【我不在乎钱】的人，要么是骗子，要么是孩子。</p><p>我相信这世上有那么几个不在乎钱的人。</p><p>他们不在乎钱，只为推动某一项成就，达到自我实现的顶层。</p><p>前提是他们的钱已经多到让自己不在乎。</p><p>钱能让人高尚，免于苟且，还能体面。</p><p>贫穷意味着局促，被迫和压抑。</p><p>勤劳变成了中性词，不褒不贬。</p><p>勤劳不会挨饿，但只有勤劳是不够的。</p><p>不存在【怀才不遇】或【有才而不富裕】。</p><p>自由市场和时间能鉴别真伪。</p><p>获取不到想要的东西，要么提升能力，要么降低需求。</p><p>但不要损，不要通过污蔑寻求安慰。</p><p>做一个诚实的人，先对自己诚实。</p><p>然后对钱诚实。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先应该承认：钱当然能买到幸福。&lt;/p&gt;
&lt;p&gt;小时候吸引自己的比较简单，零食，玩具，新衣。&lt;/p&gt;
&lt;p&gt;而吸引成年人的就是钱。&lt;/p&gt;
&lt;p&gt;踏入社会后才明白钱的意义，再也不会以花钱来换取豪爽这个虚词。&lt;/p&gt;
&lt;p&gt;很少会为了所谓的义而贬视钱，那种“我不差这点钱，我就
      
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
</feed>
