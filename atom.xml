<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>插秧哥&#39;s Blog</title>
  
  <subtitle>Never Stop Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chayangge.com/"/>
  <updated>2018-09-29T09:57:30.000Z</updated>
  <id>http://chayangge.com/</id>
  
  <author>
    <name>插秧哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB备忘</title>
    <link href="http://chayangge.com/2018/09/17/MongoDB%E5%A4%87%E5%BF%98/"/>
    <id>http://chayangge.com/2018/09/17/MongoDB备忘/</id>
    <published>2018-09-17T06:39:30.000Z</published>
    <updated>2018-09-29T09:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：<br><a id="more"></a></p><ul><li>先登录机器</li><li>链接MongoDB：mongo 10.5.XX.XX:端口</li><li>show dbs</li><li>use 某db</li><li>show tables</li><li>db.sometable.find({‘_id’:’XX’});</li><li>db.sometable.update({条件},{$set:{key:value}},{multi:true}));</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sometable.find(&#123;&apos;url&apos;:&#123;$regex:/key/i&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;表名&apos;)</span><br></pre></td></tr></table></figure><h3 id="关闭MongoDB"><a href="#关闭MongoDB" class="headerlink" title="关闭MongoDB"></a>关闭MongoDB</h3><ul><li>先退出：mongo –port 8415（只用端口号登录）</li><li>use admin</li><li>db.shutdownServer()</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cd到MongoDB安装文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f mongod.conf</span><br></pre></td></tr></table></figure><h3 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h3><p>MongoDB数据库有多个节点时，会包含一个Primary节点和多个Secondary节点，数据先写入Primary节点，其他Secondary再从Primary中同步写入的数据，因此当连接数据库后，光标起始位置会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:PRIMARY&gt;</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:SECONDARY&gt;</span><br></pre></td></tr></table></figure></p><p>当要操作Secondary节点时，由于secondary节点默认不可读，会收到一下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">&quot;code&quot; : 13435,</span><br><span class="line">&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;</span><br></pre></td></tr></table></figure></p><p>解决办法，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></p><p>但下次连接是依然报错，若想根治，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.mongorc.js</span><br><span class="line"></span><br><span class="line">增加:rs.slaveOk();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://chayangge.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://chayangge.com/2018/08/13/Base64/"/>
    <id>http://chayangge.com/2018/08/13/Base64/</id>
    <published>2018-08-12T16:03:30.000Z</published>
    <updated>2018-08-12T16:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。</p><h3 id="为什么会有Base64？"><a href="#为什么会有Base64？" class="headerlink" title="为什么会有Base64？"></a>为什么会有Base64？</h3><p>Base64加密后的信息理论上会比原信息大三分之一左右，数据变大是不利于传输的，那什么优势让它依然被使用呢？</p><p>答案是因为早期的邮件传输协议SMTP只能传输可打印的ASCII码，那不支持传输的ASCII码只能换一种编码方式，用可传输的ASCII码部分来表示信息。</p><h3 id="用了哪些字符码"><a href="#用了哪些字符码" class="headerlink" title="用了哪些字符码"></a>用了哪些字符码</h3><p>虽然名叫base64，但实际用了65个字符，因为尾部用“=”表示结束，首先从0开始，到51位分别为大小写的字母a-z，52至61为数字0-9，另外加两个字符+/，正好64。<br>所以一个标准的base64编码数据就是大小写混合夹杂数字偶尔出现+/，结尾还会有“=”。</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>转换规则如下：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/base64.png" alt="转换规则"></p><p>直接看字母的二进制数据，base64把原本的8Bit一组的数据从新按6Bit一组，然后把这新的6位二进制转换成十进制，再从10进制中找到对应的字符，组成了base64的编码。这样，无论什么数据，都能用上述64个字符表达出来，而这64个字符在所有的协议中都能顺利传输。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>base64以增加传输数据变大为代价，换取了传输的兼容性，然后仅仅在肉眼上实现了‘加密’。</p><p>前端接触最多的应用场景是用于表达图片二进制信息，把不是很大的图片用base64标识，直接放在html或css中，省去浏览器再发一个资源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。&lt;/p&gt;
&lt;h3 id=&quot;为什么会有Base64？&quot;&gt;&lt;a href=&quot;#为什么会有Base64？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有Base64？&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>天！居然断更了这么久</title>
    <link href="http://chayangge.com/2018/08/12/%E5%A4%A9%EF%BC%81%E5%B1%85%E7%84%B6%E6%96%AD%E6%9B%B4%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85/"/>
    <id>http://chayangge.com/2018/08/12/天！居然断更了这么久/</id>
    <published>2018-08-12T06:31:05.000Z</published>
    <updated>2018-08-11T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>天！居然断更了这么久，</p><p>换了份工作，</p><p>把博客落下了，</p><p>适应工作节奏后，</p><p>总感觉时间不够用，</p><p>博客就：拖…</p><p>然后，服务器又到期了，</p><p>要不要买服务器呢？买哪家？</p><p>拖…</p><p>终于又买了服务器，</p><p>换了腾讯云，</p><p>可，备案居然要重新审核，</p><p>拖…</p><p>备案终于过了，</p><p>然而，本地博客跑不起来了，</p><p>还得修，</p><p>拖…</p><p>重装了博客、改了配置、再绑域名、装git、装nginx、nginx.config 等一系列操作，</p><p>终于完成了，</p><p>总耗时接近一年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天！居然断更了这么久，&lt;/p&gt;
&lt;p&gt;换了份工作，&lt;/p&gt;
&lt;p&gt;把博客落下了，&lt;/p&gt;
&lt;p&gt;适应工作节奏后，&lt;/p&gt;
&lt;p&gt;总感觉时间不够用，&lt;/p&gt;
&lt;p&gt;博客就：拖…&lt;/p&gt;
&lt;p&gt;然后，服务器又到期了，&lt;/p&gt;
&lt;p&gt;要不要买服务器呢？买哪家？&lt;/p&gt;
&lt;p&gt;拖…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://chayangge.com/2017/08/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://chayangge.com/2017/08/21/中间件/</id>
    <published>2017-08-21T03:56:16.000Z</published>
    <updated>2017-09-04T02:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。<br><a id="more"></a><br>业界有句名言：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>“Any problem  in computer science can be solved by anther layer of indirection.”</p></blockquote><p>仔细想一下很多问题都是通过添加独立的层的概念来解决的，包括一些已经作为常识的知识，比如：互联网层的划分，从底层的物理层，到上层的应用层，彼此层之间相互独立，各司其职，以后再有什么升级或改动，保证原有层不变的基础上，添加一个层承上启下，即可。比如HTTPS就是在HTTP的基础上多了一层加密层。</p><p>而中间件的概念貌似也是如此。一个中间件就是一个功能层，相互独立，各司其职。</p><p>以express中间件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listen 3000...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(middleware1);</span><br><span class="line">app.use(middleware2);</span><br><span class="line">app.use(middleware3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3，out"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.use方法用来接收中间件1、2、3，其执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listen 3000...</span><br><span class="line">我是1</span><br><span class="line">我是2</span><br><span class="line">我是3</span><br><span class="line">我是3，out</span><br><span class="line">我是2，out</span><br><span class="line">我是1，out</span><br></pre></td></tr></table></figure></p><p>为什么遇到next后就直接跳转，等所有next执行完毕才回溯执行各自next后面的代码呢？app.use内部又是怎么回事呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从结果可以看出，多个中间件的执行顺序是按栈结构执行的，首先遇到next跳转到下一个中间件执行，直到最内部的中间值执行完毕后，才执行最内部中间件next后面的代码，执行完后才返回上一层执行上一层中间件next后面的代码，像极了洋葱图。</p><p>而在代码层面上，每当调用app.use添加中间件时，其实内部维护了一个数组，把这些追加的中间件push进去，然后反方向执行，先执行数组最末端的中间件，直到第一个push进去的中间件，这样就实现了上述中间件调用效果。demo：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>关于cookie</title>
    <link href="http://chayangge.com/2017/07/26/%E5%85%B3%E4%BA%8Ecookie/"/>
    <id>http://chayangge.com/2017/07/26/关于cookie/</id>
    <published>2017-07-26T11:02:08.000Z</published>
    <updated>2017-08-05T07:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。<br><a id="more"></a><br>大家都知道http是无状态的，也就是说在一个没有cookie技术的纯请求中，服务器分不清谁请求了，以及这次请求和上次什么关系，这导致无法标识是否登录，等等所有常规功能。如果说互联网是个随进随出的商场的话，那么cookie则相当于每个请求的帽子，这个帽子标识了每个请求的身份，且这个帽子服务器可以种植，客户端（浏览器）也可以种植。</p><h2 id="cookie的样子"><a href="#cookie的样子" class="headerlink" title="cookie的样子"></a>cookie的样子</h2><p>cookie是一段文本，之所以在浏览器中看到呈现key、value的形式，是因为保存的这段文本中是以“=”和“;”隔开的，浏览器调试工具下输入<code>documen.cookie</code>就能看到。</p><h2 id="cookie的种植"><a href="#cookie的种植" class="headerlink" title="cookie的种植"></a>cookie的种植</h2><p>上文说道，cookie的种植有两种方式，服务端和客户端，服务器返回请求内容的时候用Set-Cookie在客户端下种植cookie，也可以用浏览器的方式js手动种植，比如：documen.cookie = “key = value”;一旦cookie种植后，因同源策略，在同源下的所有请求都会带上cookie，从浏览器的开发者工具中查看：</p><p>有一点需要注意，浏览器js有个属相不能设置，那就是<code>HttpOnly 属性</code>，服务端设置HttpOnly属性后，在浏览器通过documen.cookie则不能读取cookie，相对来说增加了一层安全性，提高了破解难度，但也不是万能的。</p><h2 id="cookie存在哪？"><a href="#cookie存在哪？" class="headerlink" title="cookie存在哪？"></a>cookie存在哪？</h2><p>cookie是一段文本，并存在本地，那具体在哪里呢？<br>chrome是放在：<code>~/Library/Application\ Support/Google/Chrome/Default/Cookies</code>目录下，火狐则放在<code>~/Library/Application\ Support/Firefox/Profiles/t22mmcz1.default/cookies.sqlite</code>目录下，这些都是肉眼可看到的实实在在的文本，没什么神秘感。</p><h2 id="cookie常用的属性"><a href="#cookie常用的属性" class="headerlink" title="cookie常用的属性"></a>cookie常用的属性</h2><ul><li>expires：设置cookie的过期时间</li><li>domain：指定 cookie 将要被发送至哪个或哪些域中</li><li>path：指定了请求的资源 URL 中必须存在指定的路径时，才会带相应cookie</li><li>secure：是否要求https</li><li>HttpOnly：告知浏览器该 cookie 不能通过 JavaScript 的document.cookie访问</li></ul><h2 id="cookie的容量"><a href="#cookie的容量" class="headerlink" title="cookie的容量"></a>cookie的容量</h2><p>既然cookie能携带信息，那到底能携带多少呢？官方给出的标准是4096，但实际情况则要看浏览器了，重要的是每人会愿意在cookie上携带大量信息，因为cookie每次请求都会默认带上，如果很大，则增加了请求开销。</p><h2 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h2><p>ajax请求有同源策略，cookie也要，一个cookie又要起对应生效的域名地址，仅在本域名下才能生效，</p><h2 id="同源策略导致的问题"><a href="#同源策略导致的问题" class="headerlink" title="同源策略导致的问题"></a>同源策略导致的问题</h2><p>印绶同源策略，导致cookie不能共享，但一个大公司下的各个平台往往需要靠二级域名来区分，但对用户来说，一个账号要登录所有平台，这就导致一个问题，每个二级域名的子系统下都要登录一次？那用户岂不要疯掉，比如，你登录的新浪邮箱，当你进去微博时，提示你请登录，当你进入新浪博客时再提醒你登录。。。。，那该怎么解决该问题呢？</p><h2 id="单点登录-SSO（Single-Sign-On）"><a href="#单点登录-SSO（Single-Sign-On）" class="headerlink" title="单点登录 SSO（Single Sign On）"></a>单点登录 SSO（Single Sign On）</h2><p>单店登录解决了上述问题，用户只需在一个子系统处登录，则全站任何子系统都不用再重新登录，具体原理是：建立独立的认证中心SSO server，认证中心独立于各个站点，用来统一验证并管理登录，具体不走如下：</p><ul><li>用户在站点A输入用户名和密码点击登录 站点A将用户名和密码转发给认证中心进行认证，认证中心返回Token</li><li>站点A将当前登录用户和Token存入Session(或Cookie) 在站点A上点击连接访问站点B，通过URL参数方式，将Token带给站点B </li><li>站点B将Token转交到认证中心，认证正确，返回当前用户名。 站点B将当前登录用户和Token存入Session(或Cookie)</li><li>完成登录流程</li></ul><h2 id="cookie的安全问题"><a href="#cookie的安全问题" class="headerlink" title="cookie的安全问题"></a>cookie的安全问题</h2><p>既然在请求中用cookie标志了用户，那么如果劫持获取了cookie，就能伪造真实用户做出假冒行为，常见的攻击比如：<br>CSRF:跨站请求伪造(英语:Cross-site request forgery)，通常缩写为 CSRF 或者 XSRF， 是 种冒充 户发起请求(在 户 知情的情况下),完成 些违背 户意愿的请求(如恶意发 帖，删帖，改密码，发邮件等)。</p><p>之前文章中介绍的爬虫，在爬取需要登录的页面信息时，其实也是借用别的cookie发送的请求，和CSRF的原理是一样的。</p><p>注明的Apache服务器曾经就有一个有关cookie的漏洞，具体如下：</p><blockquote><p>Apache服务器2.2.0-2.2.21版本存在一个漏洞（CVE-2012-0053），攻击者可通过给网站植入超大的Cookie，使得HTTP头超过apache的LimitRequestFieldSize（最大请求长度）4192字节，apache便会返回400错误，状态页中就包含了http-only保护的cookies。</p></blockquote><p>简单的说就是：Apache服务器咋就cookie过多时，返回的报错信息中包含了http-only。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>简单实现双向数据绑定</title>
    <link href="http://chayangge.com/2017/04/24/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://chayangge.com/2017/04/24/简单实现双向数据绑定/</id>
    <published>2017-04-24T12:26:18.000Z</published>
    <updated>2017-04-25T02:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。<br><a id="more"></a><br>实现双向绑定的方法有三种：</p><ul><li>发布/订阅模式，比如 backbone</li><li>脏检查，比如angular，（现在angular啥样就不知道了）</li><li>以Vue为代表的数据劫持 （基于Object.defineProperty()，缺陷：IE8不支持）</li></ul><p>这里就用Object.defineProperty()来实现一个小demo，哪怕IE8不支持，但也会消亡，对此不用过于care。<br>先看html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind</span>=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imgsrc"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sayHi"</span>&gt;</span>sayHi()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先要解析html里id为app的节点内容，有v-model，v-bind，v-on，解析这些命令，得出相应的操作，解析这些节点属性用到最基本的DOM属性获取操作：childNodes、attributes。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  模板解析</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line">    <span class="keyword">var</span> nodes = app.childNodes;</span><br><span class="line">    [].slice.call(nodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">        search(ele); <span class="comment">// 这里要挨个遍历并解析app里的节点</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模板就这样，机上绑定数据，就要有相关数据和函数供模板绑定，我们使用Vue初始化实例的时候都要有data，methods等参数，这里同样也需要data和绑定函数methods，为了方便，这里就定义为$data和funs：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funs = &#123;</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi..."</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    test:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $data = &#123;</span><br><span class="line">    imgsrc:<span class="string">"https://img6.bdstatic.com/img/image/smallpic/h1.jpg"</span>,</span><br><span class="line">    value:<span class="string">"123abc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎样解析模板呢？命令提取而已，无非先去除DOM上的所有属性，从中挑出有价值的，比如以v-打头的，挑出后把带有v-打头属性的节点替换一下文本内容或添加相应的监听函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> atts = node.attributes;</span><br><span class="line">    <span class="keyword">if</span>(atts)&#123;</span><br><span class="line">        [].slice.call(atts).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name,</span><br><span class="line">                attrValue = attr.value,</span><br><span class="line">                active = attrName.substring(<span class="number">2</span>),</span><br><span class="line">                activeName = attrName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(attrName.indexOf(<span class="string">"v-"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dataMap[attrValue])&#123;</span><br><span class="line">                dataMap[attrValue].push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(attr.name.indexOf(<span class="string">"on"</span>)!== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.addEventListener(activeName,funs[attr.value],<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析 bind  v-bind:src="XXXX"</span></span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"bind"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(activeName)&#123;</span><br><span class="line">                    node.setAttribute(activeName,$data[attrValue]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.innerHTML = $data[attrValue];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"model"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.value = $data[attrValue];</span><br><span class="line">                <span class="comment">// 这是input标签双向绑定的重点</span></span><br><span class="line">                node.addEventListener(<span class="string">"input"</span>,bindInput,<span class="literal">false</span>);                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">bindInput</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                node.value = $data[attrValue] = event.target.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，到这里已经完成了对模板的初始化解析，该替换的替换，该监听的事件函数也都能添加了，但这是静态的，也就是说，只能第一次绑定data，data变动怎么办呢？这里就要用到Object.defineProperty()，该属性是ES5中的，是个好东西，没有它就没有Vue，不熟悉的可以了解一下，这里不做介绍。总之数据data变动时，会触发set操作，因此在set发生时，说明数据更新了，即可更新模板，原理就这么简单，但我们首先要做的是实现对$data的每一项进行监听，遍历一遍即可，碰到对象则递归再遍历：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    observe(val); <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val === newValue)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"老的："</span>, val, <span class="string">"变新的：--》"</span>, newValue);</span><br><span class="line">            val = newValue;</span><br><span class="line">            init(); <span class="comment">// 更新模板</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候文本框和data及p元素实现了双向数据绑定，且按钮也添加了点击事件sayHi能成功绑定执行。</p><p>至此，一个基于数据劫持的双向数据绑定demo已经完成，核心就是通过Object.defineProperty监听数据的变动，有变动则刷新模板，而模板里解析指令，并执行相应的指令或函数绑定。</p><p>但本demo运行时查看源码依然能看到写在标签元素上的指令，而vue模板源码却看不到，为什么？答案是因为vue为了增加性能，把模板节点转换成成文档碎片fragment，进行遍历加工替换等操作后，再把处理后的结果插入id为app的根DOM中，这样总体上只有一次DOM的append操作，而DOM操作是性能的杀手，vue以此提升性能，而本demo没考虑性能优化，是直接遍历替换DOM的，所以demo有很多不足，目的只为说明数据劫持实现双向数据绑定的原理，有空会再写一篇详细的作为补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。&lt;br&gt;
    
    </summary>
    
    
      <category term="mvvm" scheme="http://chayangge.com/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>公众号爬虫node版</title>
    <link href="http://chayangge.com/2017/03/28/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E8%99%ABnode%E7%89%88/"/>
    <id>http://chayangge.com/2017/03/28/公众号爬虫node版/</id>
    <published>2017-03-28T12:53:23.000Z</published>
    <updated>2017-03-29T01:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前用<a href="http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/">python实现</a>了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是<a href="https://github.com/chayangge/node-crawler" target="_blank" rel="noopener">源码</a>，数据来源<a href="http://chuansong.me/" target="_blank" rel="noopener">在这里</a>。<br><a id="more"></a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>clone并安装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/chayangge/node-crawler.git</span></span><br><span class="line">cd node-crawler</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app</span><br></pre></td></tr></table></figure></p><p>会在项目根目录下创建以微信ID命名的文件夹，里面存放抓取后的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用&lt;a href=&quot;http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/&quot;&gt;python实现&lt;/a&gt;了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是&lt;a href=&quot;https://github.com/chayangge/node-crawler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;，数据来源&lt;a href=&quot;http://chuansong.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>python的GIL</title>
    <link href="http://chayangge.com/2017/03/28/python%E7%9A%84GIL/"/>
    <id>http://chayangge.com/2017/03/28/python的GIL/</id>
    <published>2017-03-28T01:58:35.000Z</published>
    <updated>2017-03-28T07:22:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天用Python写爬虫，想用多线程写一个能充分调用CPU的高效爬虫，毕竟和js相比，Python天生支持多线程、多进程的，不像js的单线程，一次之能执行一个任务。结果无意间发现了Python的GIL，了解GIL首先要理解一下概念：线程与进程，并行与并发，单核与多核。<br><a id="more"></a></p><h2 id="线程与进程、单核与多核、并行与并发"><a href="#线程与进程、单核与多核、并行与并发" class="headerlink" title="线程与进程、单核与多核、并行与并发"></a>线程与进程、单核与多核、并行与并发</h2><p>线程是进程的子集，也就是一个进程至少包含一个线程，计算机每处理一个任务就是处理一个进程，该进程可能包含了多个线程，比如执行人执行一个跳跃动作（线程），这个动作就是由多个线程完成的，包括膝盖弯曲，脚踝发力，手臂摆动等多个组合动作。</p><p>现在的CPU都是多核了，基本上是4-8核，双核的都少了，多核相当于多个CPU。在古老的年代，CPU处理能力很低，一个单核CPU同时只能执行一个任务（虽然现在也是），这导致听歌只能听歌，播放视频只能播放视频，如果要读写文件CPU必须等着啥也不干，直到文件读取完毕才能计算，这显然不可取，所以目前操作系统采用了以下两个处理方案：</p><ul><li>每个任务都只执行一会，然后切换到其他任务（分时系统）</li><li>每个任务分配优先级权限，操作系统可强制安排优先的任务执行（抢占式）</li></ul><p>所以这形成了多任务完美『并行』的假象（即可听歌、看电影、又可同时敲代码），然而对单核CPU来说这其实是并发：多个任务同时存在，但轮流执行，同一时间只执行一个。想要并行？除非有多个CPU，也就是现在常见的多核CPU。</p><h2 id="Python的多线程与多进程"><a href="#Python的多线程与多进程" class="headerlink" title="Python的多线程与多进程"></a>Python的多线程与多进程</h2><p>以上说了这么多都是操作系统的基本知识，很多语言都能调用系统以多进程，多线程的方式运行，这里排除js，因为js天生单线程，而Python不是，即可多线程又可多进程。如果想让python爬虫执行的更快，可以：</p><ul><li>开启多线程</li><li>开启多进程</li><li>多进程下再开启多线程<br>理论上很完美，但实际上，你会碰到GIL，这个天生的紧箍咒把Python这匹千里马压制的普普通通。</li></ul><p>执行以下代码，在mac的活动监视器中查看CPU利用率：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        x = x ^ <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></p><p>上述代码启用了CPU的所有内核一起死循环，按理说每个核该跑满了显示100%，我的是4核，此时监视器应该显示400%，可实际上却显示160%，这说明CPU并没有因Python启用了多线程而充分调度起来。</p><p>语言的编译需要解释器，Python官方的解释器是CPython，也是目前用的最多的解释器，而GIL就存在CPython中，所以Python语言的指的就是CPython中的GIL（Global Interpreter Lock）即全局解释器锁。</p><p>当Python以多线程运行时，本以为可以效率翻倍，然而现实情况是：每个线程在执行前需要获得全局GIL锁才可，线程再多可GIL锁只有一个，一个线程拿到锁，运行100条字节码后必须把锁交出来，让别的线程运行一会——像不像CPU的分时系统？表面是多线程一起执行，实际上是用快速切换的方式，每个执行一会，造成一起执行的假象。</p><p>所以上述代码之所以只用全部CPU的160%，是因为受到了GIL锁的限制。</p><h2 id="有弊就有利"><a href="#有弊就有利" class="headerlink" title="有弊就有利"></a>有弊就有利</h2><p>如果一味抨击GIL的话也是不公平的，如果GIL是万恶的源头的话那么想一想：</p><ul><li>毕竟也有不带GIL的Python解释器，可为什么那些解释器没有被广泛使用呢？</li><li>如果是早期历史遗留问题，为什么Python3 依然没有摘除GIL呢？</li></ul><p>多线程是否真的完美呢？单线程真的很慢吗？并不一定。线程的却换运行需要切换线程上下文，这自然也是一笔开销，CPU忙于多线程的切换工作导致线程运行效率降低，有时反而低于单线程。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>GIL限制了多线程，也就是说GIL针对的是一个进程下的多线程，如果启用多进程呢？进城之间相互独立，也没有『进程锁』的东西，貌似可以，这也是multiprocessing的由来，用multiprocessing创建的多进程再也没有GIL的限制，就能充分利用多核CPU的性能。除此之外还有c语言扩展机制、ctypes等方法，这些没做研究，不敢瞎写。</p><h2 id="单线程的优势"><a href="#单线程的优势" class="headerlink" title="单线程的优势"></a>单线程的优势</h2><p>单线程自然有单线程的优势和应用场景，比如单线程的程序状态单一稳定，没有通信、锁等问题，也不用来回切换上下文，更好的提高CPU使用率。除此之外Nginx、nodeJS、PHP也都是单线程，但针对单线程的弊端也都有优化机制，比如nodeJS的child_process模块。</p><p>总之这是一个取舍问题，根据自己的业务环境，总有适合的技术方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天用Python写爬虫，想用多线程写一个能充分调用CPU的高效爬虫，毕竟和js相比，Python天生支持多线程、多进程的，不像js的单线程，一次之能执行一个任务。结果无意间发现了Python的GIL，了解GIL首先要理解一下概念：线程与进程，并行与并发，单核与多核。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://chayangge.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用python抓取公众号所有文章</title>
    <link href="http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    <id>http://chayangge.com/2017/03/22/用python抓取公众号文章/</id>
    <published>2017-03-22T10:14:26.000Z</published>
    <updated>2017-03-28T13:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>在我初学IT的时候，『网络爬虫』是个高大上的词汇，感觉『爬虫自动抓取』简直就是神一样的技术，不明觉厉，想到自己这么菜肯定学不会，后来了解<code>http</code>，猛然发现所谓网络爬虫本质上就是一个下载器而已。<br><a id="more"></a><br>为了消除爬虫的神秘感，重要的事情说三遍：爬虫就是一个下载器，一个下载器，下载器…</p><h2 id="那什么是下载器？"><a href="#那什么是下载器？" class="headerlink" title="那什么是下载器？"></a>那什么是下载器？</h2><p>下载器就是一个能发起http请求的东西，而浏览器可以理解为一个下载器和一个显示器的合体，那么网络爬虫就是一个能发起http请求，并从请求返回内容中筛选信息的程序。所以理解一个爬虫基本要一下几个硬知识：</p><ul><li>http是无状态的，谁都可以请求，且服务器不知道你是谁和上次什么区别（纯条件下，排除cookie、session技术）</li><li>凡是能发起请求，也就是可以网络编程的语言都可以写爬虫</li><li>各种语言为爬虫封装了各种请求框架、解析工具，写一个简单的爬虫真的很简单</li></ul><h2 id="用python写一个爬虫"><a href="#用python写一个爬虫" class="headerlink" title="用python写一个爬虫"></a>用python写一个爬虫</h2><p>python是门好语言，语法简洁优雅，还能做数据分析，爬虫技术更是相当成熟，各种包满足你各种要求，之前用python抓取过某网站的图片，感觉跟给力，现在用它做一个实用点的工具——抓取公众号文章。</p><p>公众号文章只能在手机上看，且查看历史还要一直往下滚，体验上和操作上都很麻烦，作为优质的公众号，想保存所有历史文章供日后慢慢欣赏在手机上很难实现，而有的PC网站上有但靠复制粘贴保存也费时费力，所以这个爬虫或许能解决这些问题。</p><p>首先要找到公众号文章资源，搜狗搜索提供微信公众号搜索，但只能前10篇，虽然后续可以一直抓取最新，但历史文章依然无法获取，还好有个网站，收录了公众号所有文章，就是这个<a href="http://chuansong.me/" target="_blank" rel="noopener">传送门</a>。用到了如下几个包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> requests <span class="comment">##发起请求</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="comment">##分析抓取结果</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure></p><h2 id="分析url"><a href="#分析url" class="headerlink" title="分析url"></a>分析url</h2><p>找到文章资源后就要分析页面了，我们以<a href="http://chuansong.me/account/caozsay" target="_blank" rel="noopener">caoz的梦呓</a>公众号为例，我们发现其地址信息为<code>http://chuansong.me/account/</code>+<code>公众号id</code>的形式，所以我们的爬虫要支持输入微信公众号id作为参数进行爬取:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">print</span> <span class="string">"正在搜索公众号："</span>, sys.argv[<span class="number">1</span>]</span><br><span class="line">wechat_id = sys.argv[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"抓取地址："</span>, <span class="string">"http://chuansong.me/account/"</span> + wechat_id</span><br></pre></td></tr></table></figure></p><h2 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h2><p>分析页面源码发现DOM节点清晰明了，没有后续js动态渲染，简直是爬虫的最爱：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/n/1669813351709"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">赠人玫瑰，手有余香</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"question_link"</span> <span class="attr">href</span>=<span class="string">"/n/1663085851719"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">Google关键词挖掘细分市场实战案例</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>这里说明为什么要查看源码，因为有些网站为了反爬虫，把后台数据放在js里，让前端js进行后续渲染类似前端模板的作用，这样的html源码空空如也，非常不利于抓取，但还好我们有<code>PhantomJS</code>相当于一个无界面的浏览器，依然可以搞定，这里似乎可以明白：在互联网中，几乎没什么是抓不到的，差别只在抓取难度上而已，如果难度很大，成本高，则不如自己制造数据，这样抓取就不划算了。</p><p>如上源码所示，节点清晰明了，抓取非常容易，轻轻松松获取<code>href</code>即可。至于获取方法，<code>BeautifulSoup</code>提供了非常方便的方法，如果你用过jquery的话，那更是轻松自如了，这里查看源代码即可，不过多介绍。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article_list = Soup.find_all(<span class="string">'a'</span>,class_=<span class="string">"question_link"</span>)</span><br><span class="line">page_list = Soup.select(<span class="string">".w4_5 &gt; span &gt; a"</span>)</span><br></pre></td></tr></table></figure></p><p>获得了节点序列，进行遍历，把遍历出的结果写入文件保存即可，无论是抓图还是抓取文字，都是这样。</p><h2 id="反爬虫"><a href="#反爬虫" class="headerlink" title="反爬虫"></a>反爬虫</h2><p>再次说到http，最开始http设计的时候，在当年的互联网环境下就是为了方便简洁，因此http被设计为无状态的，对服务器来说，不知道谁请求的和上次有什么关系，然而现在不能满足需求，为此设计了cookie、session技术来进行身份识别，这些是反爬虫的技术来源之一，而爬虫获取造成的服务器负担，在法律上目前属于灰色地带，如果一个网站每天被爬虫疯狂的访问，服务器看似很繁忙，然而却没有真实用户，也是件悲伤的事。更有甚者，犹豫爬虫的疯狂请求，导致服务器变慢，影响正常使用，这就算是攻击了。</p><p>所以发爬虫也很必要，常见策略有：数据用js动态加载，增加抓取难度，限制IP，如果某个IP访问频率很高，可封锁IP，但这要注意标准，以免误伤真实用户，然而封锁IP也不能从跟上解决，因为爬虫可以通过代理不停的更换IP，总之爬虫和反爬虫就是一个博弈，背后比的是成本，时间成本，技术成本，金钱成本。</p><h2 id="如何避免反爬虫"><a href="#如何避免反爬虫" class="headerlink" title="如何避免反爬虫"></a>如何避免反爬虫</h2><p>说白了就是伪装成真实用户，比如时间上不要这么疯狂，间隔个几秒，别被服务器反爬虫盯住，其次就是不停的更换请求头<code>User-Agent</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_agent_list = [</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)"</span>,</span><br><span class="line">        <span class="string">"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+"</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></p><p>这样服务器接收到请求信息就来自不同的浏览器，如果对于需要登录的网站，我们还要保存登录信息，维持cookie状态等，这里也有相应的框架和工具。</p><h2 id="爬虫优化"><a href="#爬虫优化" class="headerlink" title="爬虫优化"></a>爬虫优化</h2><p>一个能跑通的程序和可用之间还差很多细节，比如文件夹创建，保存目录，抓取提示，文件排序、代码优化等等，python并不是我的常用语言，整个实现过程也是边试边查文档，最后源代码放在<a href="https://github.com/chayangge/python-crawler" target="_blank" rel="noopener">这里</a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>下载源码后，安装相应的包，执行脚本+微信id 即可，然后就就可以看到终端显示的一条条住区进度了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python crawler.py caozsay</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我初学IT的时候，『网络爬虫』是个高大上的词汇，感觉『爬虫自动抓取』简直就是神一样的技术，不明觉厉，想到自己这么菜肯定学不会，后来了解&lt;code&gt;http&lt;/code&gt;，猛然发现所谓网络爬虫本质上就是一个下载器而已。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://chayangge.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>node与mysql</title>
    <link href="http://chayangge.com/2017/03/16/node%E8%BF%9E%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://chayangge.com/2017/03/16/node连上数据库/</id>
    <published>2017-03-16T03:26:52.000Z</published>
    <updated>2017-04-25T02:26:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都在混迹于『前端』，虽然使用node服务器，但也是用node请求java核心接口，node后台接口只做一些边边角角的逻辑，如上传，图片识别等第三放SDK，所以node对数据库的直接操作经验为零，连sql语句都忘得差不多了，这次就做了个小demo，破除一下对未知的神秘感，<a href="https://github.com/chayangge/node-express-mysql" target="_blank" rel="noopener">源码在这</a>。<br><a id="more"></a></p><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><p>两种安装方式，常规安装包下一步和brew安装，我自豪的采用brew<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure></p><p>这里有坑：安装完成后终端运行启动mysql命令无效，不给错误样式了，网上找了些处理方法，运行了几个命令就搞定了，具体哪个发挥了直接效果也说不好了，不太好复现问题，解决方法是（设置 MySQL 用户以及数据存放地址）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew link --overwrite mysql</span><br><span class="line">unset TMPDIR</span><br><span class="line">mysql_install_db --verbose --user=root</span><br></pre></td></tr></table></figure></p><p>启动mysql：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server <span class="keyword">start</span>  // 其他命令： &#123;<span class="keyword">start</span>|<span class="keyword">stop</span>|restart|reload|<span class="keyword">force</span>-reload|<span class="keyword">status</span>&#125;</span><br></pre></td></tr></table></figure></p><p>用户名密码登录mysql：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p><p>你也可以更改新密码：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password</span><br></pre></td></tr></table></figure></p><h2 id="熟悉的sql命令"><a href="#熟悉的sql命令" class="headerlink" title="熟悉的sql命令"></a>熟悉的sql命令</h2><p>登录成功后，进入mysql命令行状态，就可以操作数据库了：<br>查看数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure></p><p>+——————–+<br>| Database           |<br>+——————–+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+——————–+</p><p>新建数据库：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> myDB;</span><br></pre></td></tr></table></figure></p><p>myDB数据库中新建数据表user：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> myDB;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (<span class="keyword">ID</span> <span class="built_in">int</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,<span class="keyword">NAME</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,AGE <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p>查看数据表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></p><p>插入数据：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">"jim"</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure></p><p>查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></p><p>+—-+——+——+<br>| id | name | age  |<br>+—-+——+——+<br>|  1 | jimm |   33 |<br>+—-+——+——+<br>好，至此数据库这边已经完成，下一步开始node。</p><h2 id="假设你已安装node和express"><a href="#假设你已安装node和express" class="headerlink" title="假设你已安装node和express"></a>假设你已安装node和express</h2><p>还是用<a href="http://expressjs.com/en/starter/generator.html" target="_blank" rel="noopener">Express应用生成器</a>来创建一个完整的供成目录。</p><p>和其他平台语言一样，在工程中创建mysql通用配置文件conf.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mysql: &#123;</span><br><span class="line">        host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        user: <span class="string">'root'</span>,</span><br><span class="line">        password: <span class="string">'你的密码'</span>,</span><br><span class="line">        database: <span class="string">'myDB'</span>,</span><br><span class="line">        port: <span class="number">3306</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其次为了方便还应该创建一个增删改查的sql语言对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    insert: <span class="string">'INSERT INTO user(id, name, age) VALUES(0,?,?)'</span>,</span><br><span class="line">    update: <span class="string">'update user set name=?, age=? where id=?'</span>,</span><br><span class="line">    <span class="keyword">delete</span>: <span class="string">'delete from user where id=?'</span>,</span><br><span class="line">    queryById: <span class="string">'select * from user where id=?'</span>,</span><br><span class="line">    queryAll: <span class="string">'select * from user'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>以后需要连接数据库只需require这两个文件即可，下面开始创建数据库连接，使用的npm包是mysql：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure></p><p>安装完毕可以建立数据库连接池了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"conf.js"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"sqlMap.js"</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> pool = mysql.createPool(conf.mysql);</span><br><span class="line">pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, connection</span>) </span>&#123;</span><br><span class="line">    connection.query(<span class="string">"select * from user"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">        res.send(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样即可获取到数据库中的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来都在混迹于『前端』，虽然使用node服务器，但也是用node请求java核心接口，node后台接口只做一些边边角角的逻辑，如上传，图片识别等第三放SDK，所以node对数据库的直接操作经验为零，连sql语句都忘得差不多了，这次就做了个小demo，破除一下对未知的神秘感，&lt;a href=&quot;https://github.com/chayangge/node-express-mysql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码在这&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>从Object.prototype角度看js原型</title>
    <link href="http://chayangge.com/2017/03/08/%E4%BB%8EObject.prototype%E8%A7%92%E5%BA%A6%E7%9C%8Bjs%E5%8E%9F%E5%9E%8B/"/>
    <id>http://chayangge.com/2017/03/08/从Object.prototype角度看js原型/</id>
    <published>2017-03-08T08:16:46.000Z</published>
    <updated>2017-03-09T02:04:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：<br><a id="more"></a></p><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>为什么说<code>Object.prototype</code>是原型链的根？我们先把它打印出来开始：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.38.png" alt="Object.prototype"><br>可见，其原型上有几个熟悉的方法：</p><ul><li>hasOwnProperty</li><li>isPrototypeOf</li><li>toLocaleString</li><li>toString</li><li>valueOf</li></ul><p>这里方法的功能不是本文重点，这里不做介绍。只要记着Object的原型上有这几个方法就好,且<strong>留意hasOwnProperty函数，具体原因后续说明</strong>此时我们回忆下js的引用类型有以下几种：</p><ul><li>Object</li><li>Function</li><li>Number</li><li>RegExp</li><li>Date</li><li>Boolean</li></ul><p>我们知道这些引用型的实例就是我们常用的对象，函数，数值，正则，日期和布尔型数据，也就是说：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>首先，我们应该都知道new出的实例会继承父对象中prototype中的方法，比如我们打印Array.prototype：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/QQ20170308-194513.png" alt="Array.prototype"><br>我们看到，数组常用的方法都能在里面找到，所以new出来的数组实例arr自然拥有上述方法。但有个<strong>奇怪的函数hasOwnProperty</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(arr.hasOwnProperty)</span><br></pre></td></tr></table></figure></p><p><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8B%E5%8D%887.41.59.png" alt="arr.hasOwnProperty"><br>Array的原型中，也就是Array.prototype中并没有hasOwnProperty。</p><h2 id="arr-hasOwnProperty从哪里来？"><a href="#arr-hasOwnProperty从哪里来？" class="headerlink" title="arr.hasOwnProperty从哪里来？"></a>arr.hasOwnProperty从哪里来？</h2><p>答案就是从js的『根』中来，也就是来自Object.prototype。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>下面这句特别重要：<br>实例arr的属性方法来自实例化它的Array的原型（Array.prototype）,那Array.prototype中的方法又来自哪里？答案是：一部分是js根据Array类型特意内置的，比如说sort方法，其余类型就没有，还有一部分就是来自根：<code>Object.prototype</code>,通过神秘的<code>__proto__</code>来实现引用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.hasOwnProperty === <span class="built_in">Object</span>.prototype.hasOwnProperty) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>而<code>__proto__</code>指向实例化它的对象的原型，也就是：实例化它的对象的prototype：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>那Array.prototype对象（原型也是对象）是谁实例化的呢？上面已经揭晓，既然Array.prototype中引用了Object.prototype中的方法，自然：<br>console.log(Array.prototype.<strong>proto</strong> === Object.prototype) //true<br>到这里我们几乎可以这么理解：arr的根是Array.prototype，而Array.prototype的根，也就是js的根：<code>Object.prototype</code>,<code>Object.prototype</code>上的方法自然能被层层下属使用，hasOwnProperty就是最好的说明。<br>除Array外，其余也是如此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="comment">// .......</span></span><br></pre></td></tr></table></figure></p><blockquote><p>为什么Object.prototype中有这么多方法，本文只拿hasOwnProperty来做说明，答案是因为：其余方法如toString，valueOf会根据数据类型情况而被重写，比如Date型和Boolean型的toString和valueOf就是被重写改造后的，并没用使用根中自带的，这里就不举例了。</p></blockquote><h2 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h2><p>既然Object.prototype是根，且里面的方法可以层层被继承使用，那么这里就验证一下：<br>我们在Object.prototype上新增一个方法test：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这是来自js根中的方法！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建不同数据类型的实例:</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">arr.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">b.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line">d.test(); <span class="comment">//这是来自js根的测试方法！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...毫无疑问所有的实例都拥有了test方法</span></span><br></pre></td></tr></table></figure></p><p>上述大范围从根上扩充只是测试，一般情况下我们针对某一类型进行扩充足矣，比如js的trim方法只去两头空格，不包括中间空格，那么我们只需针对String类型在其原型上创建去全部空格方法allTrim即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.allTrim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"   aa  bb  cc   "</span>.allTrim(); <span class="comment">//aabbcc</span></span><br></pre></td></tr></table></figure></p><p>这样所有的字符串实例都有了allTrim方法，理解了js的原型，则理解了js的继承机制。</p><h2 id="一切皆空"><a href="#一切皆空" class="headerlink" title="一切皆空"></a>一切皆空</h2><p>既然Array、Function、Number的原型对象都通过<code>__proto__</code>引用自根<code>Object.prototype</code>，那么<code>Object.prototype</code>也是一个原型对象，它的根又来自哪里呢？答案是<code>null</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p><p>null 才是js原型链的终结。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js原型是该语言的核心本质，可以说，没理解js原型就没学会js，js中的各个对象通过原型链的层层引用实现了各种方法的继承。其中关系错综复杂，我们先从这些原型链的『根』开始：&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://chayangge.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>收割与被收割</title>
    <link href="http://chayangge.com/2017/03/05/2017-03-05%20%E6%94%B6%E5%89%B2%E4%B8%8E%E8%A2%AB%E6%94%B6%E5%89%B2/"/>
    <id>http://chayangge.com/2017/03/05/2017-03-05 收割与被收割/</id>
    <published>2017-03-04T16:00:00.000Z</published>
    <updated>2017-03-24T10:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>人与人之间存在一种『势能』，势能高者拥有更多的资源、经验或资历。就像老师之于学生，领导之于员工…</p><p>势能低者与高者很难形成平等有效的沟通，比如：即使加了某大V的微信也很难与之成为朋友，自己也不会成为大V。</p><p>两者相遇，势能高者完全俯视低者，控制聊天话题的走向，言行轻松自如，占尽主场优势，势能低者则要被动很多，时而献媚，时而强颜欢笑。</p><p>现在火热的『粉丝经济』、『知识付费』很多就是高势能者向低势能者的一次收割。</p><p>这本是好事，增加了知识流动，让更多人收益。但一热就不好了。</p><p>总有一些假大V，迅速包装自己，凭借他人难以辨别的所谓干货、经验，招摇撞市，宣传文案读起来热血沸腾：<br>三招让你人生逆袭<br>职场升值10大策略<br>人生7大捷径<br>创业10年我总结了这些<br>未来世界5大生存法则<br>…</p><p>知识是抽象的，可以注水、可以分割，一篇干货完全可以分10篇来写，1小时的分享完全可以注水成2小时，很难保证大V是否真诚。</p><p>真诚的大V分享的往往也是他个人以为正确的事，有些结果掺杂了很多随机因素，这些随机因素可能被总结为主要因素，甚至更为荒谬。</p><p>其次，想一个问题：你会不会把自己吃饭的看家本领到处分享？那些不为认知的核心秘密估计没人会说，哪怕说了，也是挑边边角角，或外人再也没有机会效仿的、再也无法复制的『干货』——永远正确的废话。</p><p>一不小心大脑被注入了他人的草，在你的呵护下，生根发芽，茁壮成长，直到热潮过后，凌冬来临，头脑还是一片荒原，唯一的变化是：兜里的钱又少了一部分。</p><p>收割与被收割。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人与人之间存在一种『势能』，势能高者拥有更多的资源、经验或资历。就像老师之于学生，领导之于员工…&lt;/p&gt;
&lt;p&gt;势能低者与高者很难形成平等有效的沟通，比如：即使加了某大V的微信也很难与之成为朋友，自己也不会成为大V。&lt;/p&gt;
&lt;p&gt;两者相遇，势能高者完全俯视低者，控制聊天话
      
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>关于博客</title>
    <link href="http://chayangge.com/2017/03/02/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    <id>http://chayangge.com/2017/03/02/关于博客/</id>
    <published>2017-03-02T06:23:03.000Z</published>
    <updated>2017-03-09T04:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>我从2014年开始写博客，到现在勉强快3年了，而真正意义上的持续写博客，主要还是后两年。现在看最开始写的文章，简直弱爆了，写的技术也很肤浅，虽然现在也不怎么深。我现在依然清晰的记得：2014年，躁动的我逼着自己写下了第一篇博客，并说要继续坚持，要习惯和键盘啪啪。那时候，脑子空洞，语言生涩——根本写不出来，就像做恶梦：想喊张不开嘴，想跑迈不开腿。<br><a id="more"></a><br>现在略有好转，但依然初级阶段。</p><p>博客经历了三个平台：CSDN，博客园，到现在的独立博客。前面两家都不错，CSDN可定制化太弱，记忆力除了换图没别的可更改的，而博客园则好了很多，从丰富的主题挑选，到自定义零部件，样式到js动作，还是比CSDN要好很多，更有主人的感觉，且博客园的管理员回复特别及时，不像某些平台好几天才给回复。但博客园首页貌似很多年没更新了，界面样式老旧，和Markdown编辑器相比，后台写作体验也不太好。</p><p>然后就有了现在的博客，目前为止已经换了三个主题了，越换越简洁，之前意淫的各种花哨主题，现在反而觉得厌恶。那些了博客零部件其实根本无用，文字就很好，字体、颜色，规规整整、简洁大方才是美，且内容为重。</p><p>独立博客与博客平台相比最大的优势就是完全自定义——这象征着自由。从域名，服务器，DNS解析…几乎没有任何限制，整个一套搭起来，能体会到很多细节和模糊的技术点。劣势可能就是需要自己推广，没有博客平台的蹭首页优势，阅读量需要自己来搞，这一点我到不太顾虑：以现在自己的技术水平，还不足以追求阅读量。</p><p>写博客是件挺辛苦的事，远比想象中耗时费力，编写边思考，有时还要重新查资料，写demo，贴代码，处理截图，还要站在新手的角度把知识点更好的表达出来…尤其是初始阶段，不仅体会不到乐趣，过程还异常坎坷，这可能导致很多人选择放弃。然而，挺过一段时间后，博客积累了一点数量，再整体看上去会好很多，有那么点成就感，不亚于农民伯伯看到自己播种的麦田，好吧，这也是起名插秧哥的一部分缘由。</p><p>偶尔才能感受到脑海里的满满思绪，偶尔才能体会到键盘的『绕指柔』，已经知足，毕竟还要继续，希望能从键盘的啪啪啪中体会更多乐趣。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我从2014年开始写博客，到现在勉强快3年了，而真正意义上的持续写博客，主要还是后两年。现在看最开始写的文章，简直弱爆了，写的技术也很肤浅，虽然现在也不怎么深。我现在依然清晰的记得：2014年，躁动的我逼着自己写下了第一篇博客，并说要继续坚持，要习惯和键盘啪啪。那时候，脑子空洞，语言生涩——根本写不出来，就像做恶梦：想喊张不开嘴，想跑迈不开腿。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>瞬间爱上命令行：代码提交脚本</title>
    <link href="http://chayangge.com/2017/01/24/%E7%9E%AC%E9%97%B4%E7%88%B1%E4%B8%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%9A%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC/"/>
    <id>http://chayangge.com/2017/01/24/瞬间爱上命令行：代码提交脚本/</id>
    <published>2017-01-24T07:31:38.000Z</published>
    <updated>2017-05-09T09:42:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用git的提交代码时，步骤繁琐：先add，后commit，再push：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m "备注"</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>完全可以用一个脚本减少这些重复操：<br><a id="more"></a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">if [ "$1" == "" ]</span><br><span class="line">then </span><br><span class="line">set "默认提交"</span><br><span class="line">fi</span><br><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git commit -m $1</span><br><span class="line">git push</span><br><span class="line">echo "==========提交成功=========="</span><br></pre></td></tr></table></figure></p><p>保存为cmt.sh文件放在工程下即可，但这还远远不够，因为每次提交都要在commit时做个备注，所以该脚本使用时可直接在运行命令后添加备注，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh cmt.sh 这是备注信息</span><br></pre></td></tr></table></figure></p><h2 id="这还不够"><a href="#这还不够" class="headerlink" title="这还不够"></a>这还不够</h2><p>这样方便了很多，但毕竟公司不止一个工程，难道每个项目下都要添加该脚本？当然，还有更好的办法——用alias定义成一个可全局使用的命令：<br>原理可参考这篇文章：<a href="http://chayangge.com/2016/07/18/mac%E7%BB%88%E7%AB%AF%E7%94%A8alias%E8%87%AA%E5%AE%9A%E4%B9%89shell%E5%91%BD%E4%BB%A4/">用alias自定义shell命令</a>，但这里稍有不同的是，为了维护方便，没有把alias的命令写在自己的~/.zshrc  或~/.bashrc里，而是把该脚本放在本地某个文件下，用alias指向链接即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allies  cmt='/你的脚本路径/cmt.sh'</span><br></pre></td></tr></table></figure></p><p>这样在终端直接运行命令<code>cmt</code>即可自动提交。</p><h2 id="注意（1）："><a href="#注意（1）：" class="headerlink" title="注意（1）："></a>注意（1）：</h2><p>仅仅这样执行<code>cmt</code>会提示没有权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: permission denied: /xx/xx/cmt.sh</span><br></pre></td></tr></table></figure></p><p>这是因为cmt.sh默认脚本默认是没有权限直接运行的，执行<code>ls -al</code>可看到其权限信息为：<code>-rw-r--r--</code>即自己只有读<code>r</code>(4)写<code>w</code>(2)没有执行权限<code>x</code>(1)，所以要用<code>chmod</code>命令修改权限为<code>-rwxr--r--</code>即744。所以执行命令赋予其可执行权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 cmt.sh</span><br></pre></td></tr></table></figure></p><p>这样在终端执行<code>cmt</code>可看到代码已经自动提交。</p><h2 id="注意（2）："><a href="#注意（2）：" class="headerlink" title="注意（2）："></a>注意（2）：</h2><p>如果在分支上提交失败，并提示一下信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch 分支名 has no upstream branch.</span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin 分支名</span><br></pre></td></tr></table></figure></p><p>那就执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin 分支名</span><br></pre></td></tr></table></figure></p><p>因为脚本里的push命令直接就是<code>git push</code>，而非<code>git push origin 分支名</code>，运行上述命令即可提交。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用git的提交代码时，步骤繁琐：先add，后commit，再push：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &quot;备注&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;完全可以用一个脚本减少这些重复操：&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://chayangge.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>钱的诱惑</title>
    <link href="http://chayangge.com/2017/01/18/2017-01-18%20%E9%92%B1%E7%9A%84%E8%AF%B1%E6%83%91/"/>
    <id>http://chayangge.com/2017/01/18/2017-01-18 钱的诱惑/</id>
    <published>2017-01-17T16:00:00.000Z</published>
    <updated>2017-03-24T10:15:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先应该承认：钱当然能买到幸福。</p><p>小时候吸引自己的比较简单，零食，玩具，新衣。</p><p>而吸引成年人的就是钱。</p><p>踏入社会后才明白钱的意义，再也不会以花钱来换取豪爽这个虚词。</p><p>很少会为了所谓的义而贬视钱，那种“我不差这点钱，我就是咽不下这口气”云云。</p><p>哪怕豪爽了，其实背后也是为了换取另一种东西，诸如：面子，大方，敞亮。</p><p>所以那也是交易——花钱买好感。</p><p>当诚信和钱二选一的时候，合格的并不多，尤其是在暗地里。</p><p>儿时的借钱是真诚的，甚至还能借出交情来。</p><p>成人间的借钱是忌讳的，丢失金钱甚至还会丢失朋友。</p><p>收钱者拿到还款有多高兴，还款者就有多痛苦。</p><p>而讽刺的是：这笔钱本来就属于收钱者，这笔钱本来就不属于还款者。</p><p>但在感觉上一个是意外收获，一个是掉肉之痛。</p><p>可见钱的魅力。</p><p>像吸血鬼之于鲜血。</p><p>人人计较钱，却又羞于谈钱。</p><p>终于有人自信的喊出来：我是商人，我的职责就是获取更多利益。</p><p>多么干脆利落。</p><p>等同于：我是成年人，我的职责就是要挣更多的钱。</p><p>我要挣更多的钱让自己幸福，然后让家人幸福，最后最后让身边的其他人幸福。</p><p>不偷不抢，不踩红线，还能信守承诺，这已经是上乘。</p><p>警惕那些张口闭口就是【我不在乎钱】的人，要么是骗子，要么是孩子。</p><p>我相信这世上有那么几个不在乎钱的人。</p><p>他们不在乎钱，只为推动某一项成就，达到自我实现的顶层。</p><p>前提是他们的钱已经多到让自己不在乎。</p><p>钱能让人高尚，免于苟且，还能体面。</p><p>贫穷意味着局促，被迫和压抑。</p><p>勤劳变成了中性词，不褒不贬。</p><p>勤劳不会挨饿，但只有勤劳是不够的。</p><p>不存在【怀才不遇】或【有才而不富裕】。</p><p>自由市场和时间能鉴别真伪。</p><p>获取不到想要的东西，要么提升能力，要么降低需求。</p><p>但不要损，不要通过污蔑寻求安慰。</p><p>做一个诚实的人，先对自己诚实。</p><p>然后对钱诚实。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先应该承认：钱当然能买到幸福。&lt;/p&gt;
&lt;p&gt;小时候吸引自己的比较简单，零食，玩具，新衣。&lt;/p&gt;
&lt;p&gt;而吸引成年人的就是钱。&lt;/p&gt;
&lt;p&gt;踏入社会后才明白钱的意义，再也不会以花钱来换取豪爽这个虚词。&lt;/p&gt;
&lt;p&gt;很少会为了所谓的义而贬视钱，那种“我不差这点钱，我就
      
    
    </summary>
    
    
      <category term="杂的文" scheme="http://chayangge.com/tags/%E6%9D%82%E7%9A%84%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>瞬间爱上命令行</title>
    <link href="http://chayangge.com/2017/01/12/%E7%9E%AC%E9%97%B4%E7%88%B1%E4%B8%8A%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://chayangge.com/2017/01/12/瞬间爱上命令行/</id>
    <published>2017-01-12T02:04:55.000Z</published>
    <updated>2017-01-12T02:59:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端其实命令行用的并不多，无非cd cat vi ，连mkdir都很少用到，也就一直没怎么注意过shell，听说程序员会为了省去2小时的麻烦而花4小时写个脚本，只是当个段子听听，完全体会不到背后的乐趣，可今天的一个事，让我彻底爱上命令行。<br><a id="more"></a><br>我参加了一个github公共项目，里面每个人都有提交代码，一直很想把优秀的前10名同学的代码clone下来，但github在国内的访问速度有多慢大家也都知道，再加上需要来回切换网页，挨个找到项目地址，再新建文件夹clone，下载速度很慢，且项目名都相同，必须挨个新建不重名的文件夹后再clone进去，总之：步骤繁杂，网速也慢，费时费力——这是程序员无法忍受的。</p><p>我想起了那个段子，心想要不要写个脚本呢？</p><p>抱着知难而退的犹豫态度，我看了下需求情况：发现在一个公共github项目中，各用户的仓库地址都是以项目名.git结尾，前面除用户名以外，其余都一样，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/用户名/项目名.git</span><br></pre></td></tr></table></figure><p>只有用户名变动，那就好办了，感觉可行，就立马找了个简单的shell教程，把要拷贝的用户名填进数组里，然后接下来的逻辑就很简单了，从查看语法到写出脚本，花了十来分钟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">mkdir test_shell</span><br><span class="line">cd test_shell</span><br><span class="line"></span><br><span class="line">namelist=("username" "username" "username" "username" "username" "username" "username" "username" "username")</span><br><span class="line">for data in $&#123;namelist[@]&#125;  </span><br><span class="line">do  </span><br><span class="line">mkdir $&#123;data&#125;</span><br><span class="line">cd $&#123;data&#125;</span><br><span class="line">git clone https://github.com/$&#123;data&#125;/projectname.git</span><br><span class="line">cd ..</span><br><span class="line">    echo $&#123;data&#125;  </span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>就这么抱着试试的态度运行了一遍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh test.sh //真的只是试试，文件名还是test</span><br></pre></td></tr></table></figure><p>就一遍，一下就跑通了，看着终端在屏幕上自动打印的一行行进度提示，我简直惊呆了，短短几分钟，在自动创建的文件夹下，挨个clone完毕，我只是执行了下命令，中间没有任何多余操作，真爽！</p><p>感觉shell是世界上最好的语言！有木有！</p><p>瞬间爱上命令行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端其实命令行用的并不多，无非cd cat vi ，连mkdir都很少用到，也就一直没怎么注意过shell，听说程序员会为了省去2小时的麻烦而花4小时写个脚本，只是当个段子听听，完全体会不到背后的乐趣，可今天的一个事，让我彻底爱上命令行。&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://chayangge.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>sublime自定义快捷键</title>
    <link href="http://chayangge.com/2017/01/05/sublime%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://chayangge.com/2017/01/05/sublime自定义快捷键/</id>
    <published>2017-01-05T02:39:42.000Z</published>
    <updated>2017-01-05T03:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直用的sublime3，但其默认没有删除整行快捷键，平时一直用，虽然麻烦，但也习惯了，最近搞新东西，来回注释了很多代码，这才想起：该配置一个删除整行的快捷键了。<br><a id="more"></a><br><img src="http://7xprui.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-05%20%E4%B8%8A%E5%8D%8811.02.40.png" alt="步骤"><br>菜单：Preferences -&gt; Key Blinding，进入后在右侧User自定义面板，会看到一个空数组，自己设定的快捷键和对应的命令以key：value对象的形式保存为数组元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123; <span class="string">"keys"</span>: [<span class="string">"command+d"</span>], <span class="string">"command"</span>: <span class="string">"run_macro_file"</span>, <span class="string">"args"</span>: &#123;<span class="string">"file"</span>: <span class="string">"res://Packages/Default/Delete Line.sublime-macro"</span>&#125; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>这里把删除整行命令定义为<code>command+d</code>，如果还要自定义其他命令，继续往数组里添加命令对象即可，更多命令可参考<a href="http://docs.sublimetext.info/en/latest/reference/commands.html" target="_blank" rel="noopener">官方文档</a>。<br>保存，关闭后，回到代码编辑页，<code>command+d</code>立马生效，早该这么干，一次配置终生有效，省时省力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直用的sublime3，但其默认没有删除整行快捷键，平时一直用，虽然麻烦，但也习惯了，最近搞新东西，来回注释了很多代码，这才想起：该配置一个删除整行的快捷键了。&lt;br&gt;
    
    </summary>
    
    
      <category term="sublime" scheme="http://chayangge.com/tags/sublime/"/>
    
  </entry>
  
  <entry>
    <title>公钥免密码ssh登录阿里云服务器</title>
    <link href="http://chayangge.com/2016/12/23/%E5%85%AC%E9%92%A5%E5%85%8D%E5%AF%86%E7%A0%81ssh%E7%99%BB%E5%BD%95%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://chayangge.com/2016/12/23/公钥免密码ssh登录阿里云服务器/</id>
    <published>2016-12-23T04:33:04.000Z</published>
    <updated>2017-02-06T06:58:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>从终端ssh登录阿里云服务器每次都要输入服务器ip后再输密码，很麻烦：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@101.201.XX.XX</span><br><span class="line">root@101.201.XX.XX's password: // 再输入密码</span><br></pre></td></tr></table></figure></p><p>登陆一次还有时间限制，过会没动静就掉线了，一天来回要登录好几次。<br><a id="more"></a></p><h2 id="解决方法：上传公钥"><a href="#解决方法：上传公钥" class="headerlink" title="解决方法：上传公钥"></a>解决方法：上传公钥</h2><p>把自己的公钥上传到服务器上即可，如果还没有公钥，请百度、谷歌查阅生成，这里不做介绍。<br>有了公钥后即可使用一下命令上传至服务器：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@101.201.XX.XX</span><br></pre></td></tr></table></figure></p><h2 id="背后原理"><a href="#背后原理" class="headerlink" title="背后原理"></a>背后原理</h2><p>上传成功后，下次登录时，服务器会先发出一段随机字符码，我方收到后用自己的私钥加密，注意是私钥加密，然后把加密后的码发给服务器，服务器用我方之前上传的公钥进行解密，解密成功则说明身份无误，这样就省去了输入密码这一步，设计的很机智啊。</p><h2 id="成功提示"><a href="#成功提示" class="headerlink" title="成功提示"></a>成功提示</h2><p>上传成功后，输入以下密码，会看到以下提示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number of key(s) added:        1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   "ssh 'root@101.201.XX.XX'"</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure></p><h2 id="意外报错与解决方法"><a href="#意外报错与解决方法" class="headerlink" title="意外报错与解决方法"></a>意外报错与解决方法</h2><p>在我的mac上运行<code>ssh-copy-id</code>上传公钥命令后报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: command not found: ssh-copy-id</span><br></pre></td></tr></table></figure></p><p>原因是mac上没有安装<code>ssh-copy-id</code>，执行以下命令安装：<br>Homebrew安装：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ssh-copy-id</span><br></pre></td></tr></table></figure></p><p>什么？你还没有安装Homebrew？用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/beautifulcode/ssh-copy-id-for-OSX/master/install.sh | sh</span><br></pre></td></tr></table></figure></p><p>安装完成后运行上传公钥命令即可，此时再ssh登录就不用输入密码了。</p><h2 id="ssh登录依然麻烦？还有招"><a href="#ssh登录依然麻烦？还有招" class="headerlink" title="ssh登录依然麻烦？还有招"></a>ssh登录依然麻烦？还有招</h2><p>每次登录输入<code>ssh root@101.201.XX.XX</code>还是不够简洁，那就用alias自定义一个命令吧，比如定义为：<code>goaliyun</code>，具体步骤在这一篇博客：<a href="http://chayangge.com/2016/07/18/mac%E7%BB%88%E7%AB%AF%E7%94%A8alias%E8%87%AA%E5%AE%9A%E4%B9%89shell%E5%91%BD%E4%BB%A4/">用alias自定义shell命令</a></p><hr><h2 id="补充：coding-net上免用户名和密码更新代码"><a href="#补充：coding-net上免用户名和密码更新代码" class="headerlink" title="补充：coding.net上免用户名和密码更新代码"></a>补充：coding.net上免用户名和密码更新代码</h2><p>运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config remote.origin.url https://username:password@git.coding.net/XX/XX.git</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从终端ssh登录阿里云服务器每次都要输入服务器ip后再输密码，很麻烦：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh root@101.201.XX.XX&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root@101.201.XX.XX&#39;s password: // 再输入密码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;登陆一次还有时间限制，过会没动静就掉线了，一天来回要登录好几次。&lt;br&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://chayangge.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在阿里云上部署node</title>
    <link href="http://chayangge.com/2016/12/19/%E5%9C%A8%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8A%E9%83%A8%E7%BD%B2node/"/>
    <id>http://chayangge.com/2016/12/19/在阿里云上部署node/</id>
    <published>2016-12-19T10:02:38.000Z</published>
    <updated>2016-12-22T06:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>双十一买的阿里云，最低配那种，正常价一年一千多快去拿，双十一当天五百多拿下。</p><h2 id="首先ssh登陆"><a href="#首先ssh登陆" class="headerlink" title="首先ssh登陆"></a>首先ssh登陆</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>wget <a href="http://npm.taobao.org/mirrors/node/node-latest.tar.gz" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node/node-latest.tar.gz</a></p><p>wget <a href="http://npm.taobao.org/mirrors/node/v4.4.7/node-v4.4.7.tar.gz" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/node/v4.4.7/node-v4.4.7.tar.gz</a></p><p>警告：WARNING: C++ compiler too old, need g++ 4.8 or clang++ 3.4 (CXX=g++)</p><p>gcc –version<br>gcc (GCC) 4.4.6 20110731 (AliCloud Linux 4.4.6-3)<br>Copyright © 2010 Free Software Foundation, Inc.<br>本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；<br>包括没有适销性和某一专用目的下的适用性担保。<br>[root@iZ2ze66hn1pkoq398d17saZ node-v4.4.7]# </p><p>sudo systemctl start nginx   开启nginx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;双十一买的阿里云，最低配那种，正常价一年一千多快去拿，双十一当天五百多拿下。&lt;/p&gt;
&lt;h2 id=&quot;首先ssh登陆&quot;&gt;&lt;a href=&quot;#首先ssh登陆&quot; class=&quot;headerlink&quot; title=&quot;首先ssh登陆&quot;&gt;&lt;/a&gt;首先ssh登陆&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>制作自己的IconFont</title>
    <link href="http://chayangge.com/2016/12/16/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84IconFont/"/>
    <id>http://chayangge.com/2016/12/16/制作自己的IconFont/</id>
    <published>2016-12-16T11:02:08.000Z</published>
    <updated>2018-07-01T07:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>IconFont已经广为熟知了，与图片相比其优势自然不言而喻，下面就是简单介绍一下其制作过程：</p><h2 id="所用工具fontLab"><a href="#所用工具fontLab" class="headerlink" title="所用工具fontLab"></a>所用工具fontLab</h2><p><img src="http://7xprui.com1.z0.glb.clouddn.com/icon5.png" alt="fontLab"><br><a id="more"></a><br>fontLab可以用来修改或创建图标样式。</p><h2 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h2><p>用fontLab打开一个字体文件或创建一个，至于修改过程类似ps，如果ps比较熟的话，一般这类软件应该很容易操作。<br><img src="http://7xprui.com1.z0.glb.clouddn.com/icon6.png" alt="打开后的字体文件"><br>双击打开一个字符，即可在原有图形的基础上修改，也可从新创建，一下就是演示用的一个图标（不太规范）：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/icon1.png" alt="编辑样式"><br>编辑好后，保存，file -&gt; generate font 生成字体文件(.ttf)即可。这里一定要记住该字符的unicode，写在css里，对浏览器来说，unicode就是字符，两者是一对一关系的。比如：”A”的unicode是”\u0041”,所以有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0041"</span> === <span class="string">"A"</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h2 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h2><p>我们常用的字体都是系统默认的，比如：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">'微软雅黑'</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，怎样才能让自己定义的字体被css使用呢？——用@font-face：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line">  src: url('./fonts/test.ttf') format('truetype'); // 还有.woff .eot .svg格式</span><br><span class="line">  <span class="selector-tag">font-weight</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">  <span class="selector-tag">font-style</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自己制作的字体定义为iconfont后，就可以使用了，和系统默认的使用方法一样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span>&#123;</span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候就可以使用字体图标了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试自己制作的Icon Font：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"test-icon-font"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>新建个空标签i，把字体作用在其伪元素上：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test-icon-font</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line">  <span class="attribute">text-rendering</span>: auto;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.test-icon-font</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'\f00c'</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了，刷新见效（丑了点哈）：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/icon4.png" alt="自制的图标"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IconFont已经广为熟知了，与图片相比其优势自然不言而喻，下面就是简单介绍一下其制作过程：&lt;/p&gt;
&lt;h2 id=&quot;所用工具fontLab&quot;&gt;&lt;a href=&quot;#所用工具fontLab&quot; class=&quot;headerlink&quot; title=&quot;所用工具fontLab&quot;&gt;&lt;/a&gt;所用工具fontLab&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xprui.com1.z0.glb.clouddn.com/icon5.png&quot; alt=&quot;fontLab&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://chayangge.com/tags/css/"/>
    
  </entry>
  
</feed>
