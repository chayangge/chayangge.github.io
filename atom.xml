<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>插秧哥&#39;s Blog</title>
  
  <subtitle>Never Stop Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chayangge.com/"/>
  <updated>2019-03-23T15:43:45.786Z</updated>
  <id>http://chayangge.com/</id>
  
  <author>
    <name>插秧哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《金字塔原理》</title>
    <link href="http://chayangge.com/2019/03/23/%E3%80%8A%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E3%80%8B/"/>
    <id>http://chayangge.com/2019/03/23/《金字塔原理》/</id>
    <published>2019-03-23T12:49:15.000Z</published>
    <updated>2019-03-23T15:43:45.786Z</updated>
    
    <content type="html"><![CDATA[<p>其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。<br>这句话就是写在书皮扉页上：</p><blockquote><p>金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。</p></blockquote><p>没错，这是一本工具书，本书的所有内容无非是对这段话，在表达、沟通上的详细论证和举例绘图描述，书中法门对经常汇报工作的高层来说已经是基本常识，对新人来说也谈不上高深，毕竟有些细节旁敲侧击是听说过的，经过系统性的描述和举例后会更加深刻，会清晰认识到到这本书果然是意如其名，从而在日后的沟通、写作、汇报细节上加以联=练习使用，从而成为自己的“常识”。</p><h3 id="为什么要使用金字塔原理"><a href="#为什么要使用金字塔原理" class="headerlink" title="为什么要使用金字塔原理"></a>为什么要使用金字塔原理</h3><p>也就是为什么对外输出表达要有结构？<br>数字7，或者类似范围的数字，大概5-9之间是人脑所能hold住的并发数，管理1-3个项目还是挺轻松的，5-9个项目或信息点同时汇过来，人脑就不行了，需要排个层级顺序，利于消化，并且：</p><p>人脑天然喜欢归类、抽象和总结，比如：</p><ul><li>从繁星中看到图案</li><li>从杂乱的图中看到人脸</li></ul><p>所以保证结构输出的原因是：</p><ul><li>头脑经历有限</li><li>头脑偏好归类、抽象信息，而不是杂乱分散</li></ul><h3 id="金字塔顶尖：结论先行"><a href="#金字塔顶尖：结论先行" class="headerlink" title="金字塔顶尖：结论先行"></a>金字塔顶尖：结论先行</h3><p>一步到位告诉结果，是汇报的首要前提，不要拖泥带水讲原因细节，假设有人向你汇报，你当然最想知道的就是结果如何，其次才会想了解背后原因过程。</p><h3 id="金字塔基座：原因平级归属，有逻辑，有顺序"><a href="#金字塔基座：原因平级归属，有逻辑，有顺序" class="headerlink" title="金字塔基座：原因平级归属，有逻辑，有顺序"></a>金字塔基座：原因平级归属，有逻辑，有顺序</h3><p>给出支撑结论的依据：之所以【这个结果】，是因为：1，2，3这么几项。注意：这里的1，2，3是平级且有关联的，且都是核心重头原因，如果原因1的背后还有细节子原因，请不要不在追加在后面，而是把子原因铺在下一个层级里。</p><p>归纳论点需要注意：</p><ul><li>论点之前有关联，属于同一逻辑范畴</li><li>任意上层是对其下层的总结概括</li><li>排好顺序，排序规则：按时间、大小前提，重要顺序，步骤顺序</li></ul><p>总之：纵向总结，横向逻辑统一。</p><h3 id="思考的自下而上方法"><a href="#思考的自下而上方法" class="headerlink" title="思考的自下而上方法"></a>思考的自下而上方法</h3><p>当你暂时还锚定不了一个主题，无法确定读者疑问或读者想了解什么，也就是还没有稳住金字塔塔尖，只有一对无机构的散点描述信息时，可以按自下而上的方法，构建你的金字塔：</p><ul><li>列出所有散落的点信息</li><li>找出这些点之间的关联，肯定有平级的，有关关系的，承上启下的等等</li><li>铺平，累加，找到这些点汇聚的结论，那就是金字塔塔尖</li></ul><p>自下而上完全是这本书的意外收获。</p><h3 id="信息自我归纳"><a href="#信息自我归纳" class="headerlink" title="信息自我归纳"></a>信息自我归纳</h3><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>美国商人加大对中国的投资<br>德国商人加大对中国的投资<br>可归纳为：<br>投资商们加大对中国的投资</p></blockquote><p>例子：</p><blockquote><p>日本商人加大对中国的投资<br>日本商人加大对印尼的投资<br>日本商人加大对马来的投资<br>可归纳为：<br>日本商人加大对东南亚的投资</p></blockquote><p>归纳的前提是有共同性，如果是其他分散的无关联地区则无法归纳，要记：将一个思想与其他思想共同写进谋篇文章的唯一理由，就是这个思想有利于对一个更高层次上的思想提供解释或支持。</p><h3 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h3><h4 id="因果别混杂"><a href="#因果别混杂" class="headerlink" title="因果别混杂"></a>因果别混杂</h4><p>计划行动步骤中，不要把行动和结果平级列入，要把结果写成对结果的“行动”，而非在行动中插一条无行为动作的结果信息描述。</p><h4 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h4><ul><li>各模块相互独立（mutually exclusive），相互排斥，不重叠</li><li>穷尽所有模块（collectively exhaustive），不遗漏</li></ul><p>本书最后，引用赫伯特·西蒙：解决问题只不过是通过对问题的表述，使解决方案不言自明。</p><p>于此类似的有吉德林法则：把难题清清楚楚地写出来，便已经解决了一半。</p><p>还有：暴露问题是解决的第一步。</p><p>而金字塔原理就是帮我们更好的描述问题，输出信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实很多书翻来覆去就说了一句话，《金字塔原理》这本书也是。&lt;br&gt;这句话就是写在书皮扉页上：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;金字塔的基本机构是：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://chayangge.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟new</title>
    <link href="http://chayangge.com/2019/02/28/js-%E6%A8%A1%E6%8B%9Fnew/"/>
    <id>http://chayangge.com/2019/02/28/js-模拟new/</id>
    <published>2019-02-28T05:17:11.000Z</published>
    <updated>2019-03-08T06:39:45.730Z</updated>
    
    <content type="html"><![CDATA[<p>作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bar(name,age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.habit = &apos;game&apos;;</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.strength = 60;</span><br><span class="line">bar.prototype.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">let a = new bar(&apos;tom&apos;,10);</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(a.name);</span><br><span class="line">console.log(a.age);</span><br><span class="line">console.log(a.strength);</span><br><span class="line">a.sayName();</span><br></pre></td></tr></table></figure><p>实例a可以访问构造函数中的变量，也可以访问其原型prototype上的变量和方法，下面是实现，命名为objectFactory：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objectFactory(fn,a)&#123;</span><br><span class="line">    var obj = new Object();</span><br><span class="line">    var Constructor = [].shift.call(arguments);</span><br><span class="line">    obj.__proto__ = Constructor.prototype;</span><br><span class="line">    Constructor.apply(obj, arguments);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，信息密度大，及其精妙。可以专写一篇介绍：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为关键字new，也是可以模拟的，模拟之前，先看new的基本用法和作用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:模拟call、apply</title>
    <link href="http://chayangge.com/2019/02/26/js-%E6%A8%A1%E6%8B%9Fcall%E3%80%81apply/"/>
    <id>http://chayangge.com/2019/02/26/js-模拟call、apply/</id>
    <published>2019-02-26T15:08:36.000Z</published>
    <updated>2019-02-26T18:25:51.232Z</updated>
    
    <content type="html"><![CDATA[<p>call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p><p>看个应用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var value = 456;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    value: 11,</span><br><span class="line">    test: function()&#123;</span><br><span class="line">        console.log(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">test.call(obj);</span><br></pre></td></tr></table></figure><p>如果不用call，我们的代码不得不这样，把test放到obj里才行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    // 需要把函数放在obj里才行</span><br><span class="line">    bar: function() &#123;</span><br><span class="line">        console.log(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); // 1</span><br></pre></td></tr></table></figure><p>demo中通过调用call，让test中this的指向改为obj。</p><h3 id="模拟call"><a href="#模拟call" class="headerlink" title="模拟call"></a>模拟call</h3><p>原生的call方法是挂载在Function.prototype上的，下面就模拟实现一个call2：<br>模拟原理：</p><ul><li>先把函数放在obj里，获得了想要的this指向</li><li>执行obj.函数</li><li>删除obj.函数，保证obj原状不变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj)&#123;</span><br><span class="line">    obj.fn = this; // 重点：this指向的实例，Function的实例就是函数bar</span><br><span class="line">    obj.fn();</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo); // 1</span><br></pre></td></tr></table></figure><p>到这原理就讲完了，但call是能带参数的，且还有类似固定参数的apply呢<br>实现带参call2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(obj,a,b)&#123;</span><br><span class="line">    obj.fn = this;</span><br><span class="line">    obj.fn(a,b);</span><br><span class="line">    delete fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(a,b) &#123;</span><br><span class="line">    console.log(this.value,a,b);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo,1,2); // 1,1,2</span><br></pre></td></tr></table></figure><p>但现实中call的参数是不固定的，第第一位始终是要嫁接的obj，所以参数只能从arguments数组的第1为开始取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用eval拼接出参数（a,b,c）的效果，args会自动调用toString方法</span><br><span class="line">    delete context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><p>有些函数需要返回：比如函数结果是return一个什么东西，比如return 一个obj对象之类:<br>还有 call可以传null的，传null意味着在全局window上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bar(name, age) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        value: this.value,</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bar() // return出一个对象</span><br></pre></td></tr></table></figure><p>这里也是可以轻松实现的，原理是把fn执行的结果收集起来，再用return扔出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.call2 = function(context) &#123;</span><br><span class="line">    var context = context || window; // 为null时，context为window</span><br><span class="line">    context.fn = this;</span><br><span class="line">    var args = [];</span><br><span class="line">    for(var i = 1, len = arguments.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    let result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); // 重点：用result手机函数运行结果，并return出去</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return result; // return 出去</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo, &apos;kevin&apos;, 18); </span><br><span class="line">// kevin</span><br><span class="line">// 18</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h3 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h3><p>apply的唯一区别就是参数固定，所以第二个参数直接一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.apply = function (context, arr) &#123;</span><br><span class="line">    var context = Object(context) || window;</span><br><span class="line">    context.fn = this;</span><br><span class="line"></span><br><span class="line">    var result;</span><br><span class="line">    if (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        var args = [];</span><br><span class="line">        for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(&apos;arr[&apos; + i + &apos;]&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete context.fn</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟bind"><a href="#模拟bind" class="headerlink" title="模拟bind"></a>模拟bind</h3><p>先看看bind的特性：</p><ul><li>依然是借窝下蛋的功能</li><li>但返回一个新的函数</li><li>函数可传参，且参数可以再bind的时候产一部分，在执行的时候再传一部分</li></ul><p>最简单实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind2 = function(obj)&#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return self.apply(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试一下</span><br><span class="line">var foo = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    console.log(this.value);</span><br><span class="line">&#125;</span><br><span class="line">let a = bar.bind2(foo);</span><br><span class="line">console.log(&apos;a:&apos;,a);</span><br><span class="line">a() // 1</span><br></pre></td></tr></table></figure><p>实现和原理见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call的用法：借窝下蛋，使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。&lt;/p&gt;
&lt;p&gt;看个应用场景：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:变量解析</title>
    <link href="http://chayangge.com/2019/02/19/js-%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://chayangge.com/2019/02/19/js-变量解析/</id>
    <published>2019-02-18T16:17:58.000Z</published>
    <updated>2019-02-20T06:10:20.027Z</updated>
    
    <content type="html"><![CDATA[<p>js在执行前会创建可执行上下文，执行上下文中中包含：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>执行上下文中的变量我们称为：活动对象(activation object, AO)。</p><p><strong>js对执行上下文中的代码有两部处理：1.进入执行上下文，进行各自的声明；2.执行，对声明赋值</strong><br>进入阶段，其中变量对象的状态为：</p><ul><li>arguments即形参，被赋值的形参为key:value，未赋值的为key:undefined</li><li>函数声明，注意：函数的声明一定提前于变量</li><li>变量声明，只有声明变量占位，并没有值</li></ul><p>demo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;</span><br><span class="line">    var a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>进入阶段的AO是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    a: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以能正常打印a，是因为执行打印时，函数已经提前【扫描】了内部变量，arguments作为实参，有实参则有值，无实参则undefined，函数提前，变量声明提前，只是没赋值，此时为undefined，执行到后续的的复制命令时a才会为3.</p><p>改一下，把内部的var a = 3;去除var，变为a = 3 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2);  // 1,undefined</span><br><span class="line">    console.log(a); // 此处会报错：ReferenceError: a is not defined</span><br><span class="line">    console.log(c); </span><br><span class="line">    a = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><p>因为去除var后，没有变量声明，在进入时，上下文中根本不会声明变量a，在执行阶段发现本作用域中没有a，则往上找，依然没有，则报错。<br>在进入阶段的AO为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        1: undefined,</span><br><span class="line">        length: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    // 根本没有a，也不存在undefined,</span><br><span class="line"></span><br><span class="line">    c: reference to function c()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>函数优于变量提前声明</li><li>变量与形参重名时，变量声明不影响形参，如下demo：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function test(item1,item2)&#123;</span><br><span class="line">    console.log(item1,item2); // 1, undefined</span><br><span class="line">    console.log(c); // c()&#123;&#125;  而不是undefined，因为函数提前</span><br><span class="line">    var c = 3;</span><br><span class="line">    function c()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    var item1;</span><br><span class="line">    console.log(item1); // 依然是1，没赋值，不会影响形参item1</span><br><span class="line">&#125;</span><br><span class="line">test(1);</span><br></pre></td></tr></table></figure><h3 id="与静态作用域的关系"><a href="#与静态作用域的关系" class="headerlink" title="与静态作用域的关系"></a>与静态作用域的关系</h3><p>上文中说过js的作用域是静态的，函数无论在哪里执行，其内部变量的作用域始终为创建函数是固定的，通过观察AO发现果然如此，在函数执行前去，创建作用域栈，解析当前作用域下的变量，产生了固定的AO。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;js在执行前会创建可执行上下文，执行上下文中中包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量对象&lt;/li&gt;
&lt;li&gt;作用域链&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行上下文中的变量我们称为：活动对象(activation object, AO)。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:静态作用域</title>
    <link href="http://chayangge.com/2019/02/18/js-%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://chayangge.com/2019/02/18/js-静态作用域/</id>
    <published>2019-02-18T05:03:42.000Z</published>
    <updated>2019-02-18T06:24:06.246Z</updated>
    
    <content type="html"><![CDATA[<p>作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。<br><a id="more"></a><br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // 1</span><br></pre></td></tr></table></figure></p><p>无论foo在哪里执行，其寻找变量的始终为创建时全局的value，而非bar中定义的value。如果js是动态作用域那打印的肯定是2了。</p><p>换个复杂点的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>以及：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope = &quot;local scope&quot;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return scope;</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>毫无疑问：都是local scope，无论f在哪执行，哪怕被return出去，其中变量作用域始终为创建时的“local scope”。</p><h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>上述demo中两个checkscope的实现方式虽然结果相同，但执行上下文栈是不同的：<br>当js执行一个函数的时候，会创建一个执行上下文压栈，当有n个执行任务的时候，通过执行上下文栈来管理执行顺序，然后挨个执行出栈，最后的栈低永远是全局上下文globalContext。<br>demo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&apos;fun3&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure></p><p>所以执行上下文栈为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//先执行fn1</span><br><span class="line">ECStack.push(fn1)</span><br><span class="line"></span><br><span class="line">// 发现fn1里调用了fn2，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn2)</span><br><span class="line"></span><br><span class="line">// 发现fn2里调用了fn3，再次创建一个执行上下文入栈</span><br><span class="line">ECStack.push(fn3)</span><br><span class="line"></span><br><span class="line">// 终于fn3得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// fun2执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// fun1执行完毕</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 最后ECStack中剩下globalContext</span><br></pre></td></tr></table></figure></p><p>那上述checkscope的demo中两个虽结果一样，但执行上线文栈为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//发现里面调用了f()</span><br><span class="line">ECStack.push(f)</span><br><span class="line"></span><br><span class="line">// 终于f得到执行，pop出栈</span><br><span class="line">ECStack.pop();</span><br><span class="line">// checkscope执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>第二个checkscope()();的例子为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(checkscope)</span><br><span class="line"></span><br><span class="line">//checkscope()运行结束了，pop</span><br><span class="line">ECStack.pop();</span><br><span class="line"></span><br><span class="line">// 发现checkscope()后面又有个()，也就是还有执行任务f，那再push</span><br><span class="line">ECStack.push(f)</span><br><span class="line">// f执行完毕</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作用域指代码中定义变量的区域，js是静态作用于，核心点在于：无论function在哪里执行，function中使用的变量，始终为定义function时的变量。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js:按值传递</title>
    <link href="http://chayangge.com/2019/02/16/js-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://chayangge.com/2019/02/16/js-按值传递/</id>
    <published>2019-02-16T07:29:10.000Z</published>
    <updated>2019-02-16T08:03:25.614Z</updated>
    
    <content type="html"><![CDATA[<p>js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；<br><a id="more"></a><br>demo1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f(a,b,c) &#123;</span><br><span class="line">   a = 3;</span><br><span class="line">   b.push(&quot;foo&quot;);</span><br><span class="line">   c.first = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 4;</span><br><span class="line">var y = [&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;];</span><br><span class="line">var z = &#123;first: true&#125;;</span><br><span class="line">f(x,y,z); // x:3 y:[&quot;eeny&quot;, &quot;miny&quot;, &quot;mo&quot;, &apos;foo&apos;]  z: &#123;first: false&#125;</span><br></pre></td></tr></table></figure></p><p>x 是原始数据，y、z是引用数据，传入函数内的是x的值3，y、z的引用地址，所以内部通过地址引用操作内存【堆】中的引用型数据。</p><h3 id="共享传递-？"><a href="#共享传递-？" class="headerlink" title="共享传递 ？"></a>共享传递 ？</h3><p>demo2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;;</span><br><span class="line">function foo(o) &#123;</span><br><span class="line">    o = 2;</span><br><span class="line">    console.log(o); //2</span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line">console.log(obj.value) // 1</span><br></pre></td></tr></table></figure></p><p>上述例子中obj传入函数中的是引用地址的拷贝，被命令为o，当这个地址被重新复制后，切断了原有向堆中的指向，被新赋值为原始数据2，而堆中的数据不变，且依然被obj变量指向着。 </p><p>这也被称为共享传递，但因为共享传递中传递的是地址，地址被一个变量代表着，所以在《js高程》中称js为值传递。</p><p>demo2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined  ??</span><br></pre></td></tr></table></figure><p>首先复制运算从右向左，且.符号优先级最大，a为{a:1}的引用地址（是个变量值），真正的引用数据有两个分别是：{a:1}和{a:2}，那么赋值运算可拆解为：</p><p>a.x = a = {a:2}; （新内存：{a:2}）赋值给 ==&gt; (引用地址a) 赋值给==&gt; （原内存a：{a:1}）.x</p><p>所以原内位置的数据被修改为：{a:1,x:{a:2}}<br>变量a指向的是新创建的内存：{a:2}<br>所以：a是{a:2} a.x是undefined<br>而老内存{a:1,x:{a:2}} 因为已经没有被任何变量引用，而被销毁。</p><p>为了验证老内存，防止被销毁，新建一个变量b来指向它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;a:1&#125;;</span><br><span class="line">let b = a;</span><br><span class="line">a.x = a = &#123;a:2&#125;;</span><br><span class="line">console.log(a); // &#123;a:2&#125;</span><br><span class="line">console.log(a.x); // undefined </span><br><span class="line">console.log(b); // &#123;a:1,x:&#123;a:2&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>变量b始终指向老内存{a:1}，且老内存被追加属性x后，不会被销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js是按值传递的，这个值对原始数据类型来说是value，对引用型数据来说是引用（即地址）；&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>package.json散落知识点</title>
    <link href="http://chayangge.com/2019/01/02/package.json%E6%95%A3%E7%82%B9%E6%8B%BE%E9%81%97/"/>
    <id>http://chayangge.com/2019/01/02/package.json散点拾遗/</id>
    <published>2019-01-02T03:07:16.000Z</published>
    <updated>2019-01-02T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集散落的package.json相关知识，日后会不断丰富和补充：<br><a id="more"></a></p><h3 id="自定义命令和内置命令"><a href="#自定义命令和内置命令" class="headerlink" title="自定义命令和内置命令"></a>自定义命令和内置命令</h3><p>我们都知道可以再script中定义命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;gulp&quot;,</span><br><span class="line">    &quot;mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;lc-mock-start&quot;: &quot;XXX&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;npm run lint&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>但这些命令一些可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p><p>有些则需要加run才行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run mock-start</span><br></pre></td></tr></table></figure></p><p>不需要加run的就是npm内置命令，出start之外还有：</p><ul><li>test</li><li>stop</li><li>restart</li></ul><h3 id="语义化版本号"><a href="#语义化版本号" class="headerlink" title="语义化版本号"></a>语义化版本号</h3><p>约定一个包的版本号包含3个数字：主版本号.小版本号.修订版本号。</p><ul><li>MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号</li><li>MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号</li><li>PATCH 对应修订版本号，一般针对修复 BUG 的版本号<br>具体见：<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">https://semver.org/lang/zh-CN/</a></li></ul><h3 id="版本匹配"><a href="#版本匹配" class="headerlink" title="版本匹配"></a>版本匹配</h3><p>经常看到入校版本信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">   &quot;copy-to-clipboard&quot;: &quot;^3.0.8&quot;,</span><br><span class="line">   &quot;immutable&quot;: &quot;^3.8.2&quot;,</span><br><span class="line">   &quot;react&quot;: &quot;~16.3.2&quot;,</span><br><span class="line">   &quot;react-dom&quot;: &quot;*16.3.2&quot;,</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>版本前有^和~两个符号，代表的意思分别为：</p><ul><li>^ 大版本匹配：如^3.0.8会匹配大版本3下的所有小版本（从3.0.0到3.9.9）</li><li>~ 小版本匹配：如~3.0.8会匹配小版本3.0.X下的所有小版本(从3.0.0到3.0.9)</li><li>*代表安装最新版本的包</li></ul><p>所以不推荐^和*</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文收集散落的package.json相关知识，日后会不断丰富和补充：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>笔尖下的深刻——村上春树</title>
    <link href="http://chayangge.com/2018/12/28/%E7%AC%94%E5%B0%96%E4%B8%8B%E7%9A%84%E6%B7%B1%E5%88%BB%E2%80%94%E2%80%94%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    <id>http://chayangge.com/2018/12/28/笔尖下的深刻——村上春树/</id>
    <published>2018-12-28T08:57:33.000Z</published>
    <updated>2018-12-28T11:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章太美，忍不住挂在博客上：<br><a id="more"></a></p></blockquote><hr><p>每一个人都有属于自己的一片森林，迷失的人迷失了，相逢的人会再相逢。</p><p>如果我爱你，而你也正巧的爱我。你头发乱了时候，我会笑笑的替你拨一波，然后，手还留恋的在你发上多待几秒。但是，如果我爱你，而你不巧的不爱我。你头发乱了，我只会轻轻的告诉你，你头发乱了喔。这大概是最纯粹的爱情观，如若相爱，便携手到老;如若错过，便护他安好。</p><p>尽管世界上有那般广阔的空间，而容纳你的空间——虽然只需一点点——却无处可寻。</p><p>于是我关闭我的语言，关闭我的心，深沉的悲哀是连眼泪这形式都无法采取的东西。</p><p>你要做一个不动声色的大人了。不准情绪化，不准偷偷想念，不准回头看。去过自己另外的生活。你要听话，不是所有的鱼都会生活在同一片海里。</p><p>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老。</p><p>试着这样想：我们每一个人，都或多或少地，是一枚鸡蛋。我们每一个人都是一个独特的、不可替代的灵魂，而这灵魂覆盖着一个脆弱的外壳。这就是我自己的真相，而且这也是你们每一个人的真相。</p><p>不管全世界所有人怎么说，我都认为自己的感受才是正确的。无论别人怎么看，我绝不打乱自己的节奏。喜欢的事自然可以坚持，不喜欢的怎么也长久不了。</p><p>每一次，当他伤害我时，我会用过去那些美好的回忆来原谅他，然而，再美好的回忆也有用完的一天，到了最后只剩下回忆的残骸，一切都变成了折磨，也许我的确是从来不认识他。</p><p>这是个无情的世界，因为有希望的地方就必定有磨炼。</p><p>孤独一人也没关系，只要能发自内心地爱着一个人，人生就会有救。哪怕不能和他生活在一起。</p><p>人，人生，在本质上是孤独的，无奈的。所以需要与人交往，以求相互理解。然而相互理解果真可能吗?不，不可能，宿命式的不可能，寻求理解的努力是徒劳的。与其勉强通过交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈!</p><p>世界上有什么不会失去的东西吗？我相信有，你也最好相信。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章太美，忍不住挂在博客上：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack loader</title>
    <link href="http://chayangge.com/2018/12/24/webpack%20loader/"/>
    <id>http://chayangge.com/2018/12/24/webpack loader/</id>
    <published>2018-12-23T17:36:34.000Z</published>
    <updated>2018-12-23T17:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先熟悉loader"><a href="#先熟悉loader" class="headerlink" title="先熟悉loader"></a>先熟悉loader</h3><p>webpack只能处理js，对于非js的文件需要对应的loader转换成webpack能处理的模块，在进行打包，如JSX、TS、less等。</p><p>loader本质上是一个function，且按照node普通模块的方式编写，既可以是本地的一个文件，也可以打成一个npm包（项目中都是npm）。function用参数传入代码，然后按转换代码，最后输出代码。</p><h3 id="loader基本用法"><a href="#loader基本用法" class="headerlink" title="loader基本用法"></a>loader基本用法</h3><p>官方是使用方法这里过多介绍，只说明一下自己开发的本地loader使用方式，下面自己实现处理less的两个常用loader，分别为’style-loader’, ‘less-loader’，后者翻译less，前者把翻译后的css插入前端代码中。</p><p>在webpack.config.js中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./src/index.js&apos;, // 入口文件</span><br><span class="line">    output: &#123; // webpack打包后出口文件</span><br><span class="line">        filename: &apos;build.js&apos;, // 打包后js文件名称</span><br><span class="line">        path: path.resolve(__dirname, &apos;dist&apos;) // 打包后自动输出目录</span><br><span class="line">    &#125;,</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        // 定义自己的loader位置</span><br><span class="line">        modules: [path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;source-map&apos;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        // loader 默认从右向左、从下往上执行，可用enforce：‘pre’ normal,inlineLoader,post设定最先执行</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.less$/,</span><br><span class="line">                use: [&apos;style-loader&apos;, &apos;less-loader&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如上所示，用resolveLoader定义了loader的读取位置为本地的loaders文件夹，下面在该文件夹中定义这两个laoder的js文件，先以less-loader为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    // 这里处理source</span><br><span class="line">    console.log(&apos;我是自定义loader&apos;);</span><br><span class="line">    return source;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>此时运行webpack，会执行此loader并打印:’我是自定义loader。</p><p>loader作为一个流水线上的某个处理环节，传入了内容（String或Buffer），处理内容，最后输出内容，且输出作为下一个loader的输入，下面加入处理程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let less = require(&apos;less&apos;);</span><br><span class="line">function loader (source) &#123;</span><br><span class="line">    console.log(&apos;run loader...222&apos;, source);</span><br><span class="line">    console.log(&apos;this:&apos;, this);</span><br><span class="line">    let css;</span><br><span class="line">    less.render(source, function (error, output) &#123;</span><br><span class="line">        css = output.css;</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(&apos;我是翻译后的css:&apos;, css);</span><br><span class="line">    return css;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>至此，一个最基本的less文件loader就已经实现。</p><p>下面是style-loader，其作用是把css代码按最基础的方式插入页面中，所谓最基础的方式就是把css代码拼到style标签中，单后插入head标签里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure></p><p>运行webpack –mode development，会看到输出结果，并在dist目录中的未压缩build.js中看到具体的css代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/***/ &apos;./src/index.js&apos;:</span><br><span class="line">    /*! **********************!*\</span><br><span class="line">  !*** ./src/index.js ***!</span><br><span class="line">  \**********************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports, __webpack_require__) &#123;</span><br><span class="line">        __webpack_require__(/*! ./index.less */ &apos;./src/index.less&apos;);</span><br><span class="line">        document.querySelector(&apos;#root&apos;).innerHTML = &apos;&lt;h1&gt;Hello World!&lt;/h1&gt;&apos;;</span><br><span class="line">        /***/ &#125;,</span><br><span class="line"></span><br><span class="line">    /***/ &apos;./src/index.less&apos;:</span><br><span class="line">    /*! ************************!*\</span><br><span class="line">  !*** ./src/index.less ***!</span><br><span class="line">  \************************/</span><br><span class="line">    /*! no static exports found */</span><br><span class="line">    /***/ function (module, exports) &#123;</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = &apos;h1 &#123;\n  color: red;\n&#125;\n&apos;;</span><br><span class="line">        document.head.appendChild(style);</span><br><span class="line">        /***/ &#125;</span><br><span class="line"></span><br><span class="line">/******/ &#125;);</span><br></pre></td></tr></table></figure><p>在浏览器打开，将看到红色的hello word，说明两个loader已经正常运行。</p><h3 id="pitch"><a href="#pitch" class="headerlink" title="pitch"></a>pitch</h3><p>每个loader的function都有pitch属性方法，虽然loader的执行方式是从右向左，总下往上，但每个loader的pich是按常规顺序执行的，可以在某个laoder中打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function loader (source) &#123;</span><br><span class="line">    let str = `</span><br><span class="line">        let style = document.createElement(&apos;style&apos;);</span><br><span class="line">        style.innerHTML = $&#123;JSON.stringify(source)&#125;</span><br><span class="line">        document.head.appendChild(style)</span><br><span class="line">    `;</span><br><span class="line">    console.log(&apos;我是拼接好的插入代码：&apos;, str);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line">loader.pitch = function () &#123;</span><br><span class="line">    console.log(&apos;我是less-loader的pitch，我先执行&apos;);</span><br><span class="line">    //return &apos;source&apos; 一旦return，后续的loader将不执行</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = loader;</span><br></pre></td></tr></table></figure><p>当pitch中有return时，不在执行后面的loader，pitch在内部是以递归方式执行，当递归到底时，再执行loader，类似于koa中间件的洋葱模型，或理解为先入后出的栈模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|- style-loader `pitch`</span><br><span class="line">  |- less-loader `pitch`</span><br><span class="line">    // 递归到底</span><br><span class="line">  |- less-loader normal execution</span><br><span class="line">|- style-loader normal execution</span><br></pre></td></tr></table></figure></p><p>上面所写的两个loader过于简单，未涉及loader中的this，在每一个loader的上下文中都能通过this获取到loader的相关API，应对更多的功能场景，关于更多this上的API见<a href="https://webpack.js.org/api/loaders/" target="_blank" rel="noopener">文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;先熟悉loader&quot;&gt;&lt;a href=&quot;#先熟悉loader&quot; class=&quot;headerlink&quot; title=&quot;先熟悉loader&quot;&gt;&lt;/a&gt;先熟悉loader&lt;/h3&gt;&lt;p&gt;webpack只能处理js，对于非js的文件需要对应的loader转换成webpac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://chayangge.com/2018/11/26/Promise/"/>
    <id>http://chayangge.com/2018/11/26/Promise/</id>
    <published>2018-11-25T17:52:02.000Z</published>
    <updated>2018-11-26T02:44:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。<br>Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。<br><a id="more"></a><br>Promise主要解决嵌套异步回调问题，退一步想，只是代码形式上的“重组”，而promise就是重组嵌套代码的盒子，这个盒子规定：把触发逻辑写在resolve里，回调都写在then里，这样的代码形式则变得优雅很多。</p><p>回调地狱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./test.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">        fs.readFile(data,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">            console.log(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promis后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function read(filePath,encoding)&#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">            if(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;./test.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return read(data,&apos;utf8&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    return data.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)...</span><br></pre></td></tr></table></figure></p><p>当然，应用广泛的Promise是有规范的，可以根据规范自己实现。规范也是人定的，甚至还可以抛弃规范去写自己心目中的代码。</p><p>如上面所说，Promise是代码形式上的“重组”工具，把触发代码和回调代码，以利于阅读和维护的方式重组，其中触发代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath,encoding,(err,data)=&gt;&#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">    reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>回调代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.then((data)=&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样理解起来，对Promise整体就有了全局的认识，接下来要实现的就是这个工具，这个工具的核心是：</p><ul><li>1.触发函数在新建Promise时先执行，并根据结果设定好是走resolve还是reject</li><li>2.then里的回调函数在触发后执行，这就意味着要先注册这些回调（resolve回调和reject的回调）</li><li>3.Promise要能链式调用，且每个链式产生的是一个全新的Promise（非jQuery中直接return this，而是return new Promise）</li></ul><p>###最小Promise<br>先实现一个最小功能的Promise，仅实现上述1，2功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>触发逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    resolve(a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t.then((value)=&gt;&#123;</span><br><span class="line">    console.log(&apos;执行成功：&apos;,value);</span><br><span class="line">&#125;,(value) =&gt; &#123;</span><br><span class="line">    console.log(&apos;执行失败：&apos;,value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上述就是最简易的Promise，上来就先执行了resolve，然后执行了then中onResole的回调。</p><p>但在实际中Promise的触发逻辑都是异步的，比如发起请求，这里用setTimeout模拟：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let t = new Promisee((resolve,reject) =&gt; &#123;</span><br><span class="line">    let a = 1;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(a);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里因为触发函数是异步的，所以then优先于resolve执行，而此时的状态还是最初的PEDDING，为此，Promise要继续丰富这种情况，保证then里的代码优先注册，必须当resolve执行后，才执行then中注册的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function Promisee(fn)&#123;</span><br><span class="line">    this.state = &apos;PENDING&apos;;</span><br><span class="line">    this.value = null;</span><br><span class="line">    this.onResolvedCallback = [];</span><br><span class="line">    this.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">    resolve = (value) =&gt; &#123;</span><br><span class="line">        this.state = &apos;RESOLVED&apos;</span><br><span class="line">        this.value = value;</span><br><span class="line">        console.log(this.onResolvedCallback.length);</span><br><span class="line">        for(var i = 0; i &lt; this.onResolvedCallback.length; i++) &#123;</span><br><span class="line">            this.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    reject = (error) =&gt; &#123;</span><br><span class="line">        this.state = &apos;REJECTED&apos;</span><br><span class="line">        this.value = error;</span><br><span class="line">        for(var i = 0; i &lt; this.onRejectedCallback.length; i++) &#123;</span><br><span class="line">            this.onRejectedCallback[i](error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    fn(resolve,reject)</span><br><span class="line">&#125;</span><br><span class="line">Promisee.prototype.then = function(onResole,onReject)&#123;</span><br><span class="line">        if(this.state === &apos;RESOLVED&apos;)&#123;</span><br><span class="line">            onResole(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;REJECTED&apos;)&#123;</span><br><span class="line">            onReject(this.value)</span><br><span class="line">        &#125;</span><br><span class="line">        else if(this.state === &apos;PENDING&apos;)&#123;</span><br><span class="line">            this.onResolvedCallback.push(onResole);</span><br><span class="line">            this.onRejectedCallback.push(onReject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>仔细对比改造前后的代码，会发现有以下核心改动点：</p><ul><li>then里当PENDING状态时分别存到onResolvedCallback和onRejectedCallback数组里，解决了上述中因异步触发函数导致缺失PENDING状态的问题</li><li>resolve或reject执行时，遍历各自的数组栈，把之前then中存进去的回调函数通通在此时执行</li></ul><p>这时候的触发函数终于可以写成常见的异步了。</p><p>下面只剩下一个问题3：then链式调用，then返回的是一个全新的Promise，需在then的三种情况下都返回一个new Promise，且新promise的输入是上一个promise的输出，也就是上一个promise中then里的回调函数执行结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越是高级语言，高封装度的框架，使用起来代码越倾向于配置，就像css，几乎就是一门纯配置语言。&lt;br&gt;Promise一直在用，基本都是在写Promise的配置，现在想想还是研究一下内部。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符、ASCII码、Unicode、UTF-8、emoji</title>
    <link href="http://chayangge.com/2018/10/30/UTF-8/"/>
    <id>http://chayangge.com/2018/10/30/UTF-8/</id>
    <published>2018-10-30T02:30:52.000Z</published>
    <updated>2018-12-30T13:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机供01高低电位表示信息，01也是最小逻辑单元。</p><p>一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）</p><p>ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小写，以及32个不能打印出来的控制符。</p><p>英文肯定是够用了，但有上万个字符的中文及其他语言就不行了。</p><p>所以GB2312编码来了，用两个字节表示一个汉字，也就是16个bit位，终于满足所有汉字了。</p><p>但每个语言都搞一套编码，不够国际化，别的编码方式的浏览器打开中文都是乱码。</p><p>所以Unicode出现了，uni + code （统一 + 编码）</p><p>终于能把全世界的语言字符表达完了。</p><p>但有个问题：浪费存储空间，很多排在后面的特殊字符要用4个甚至给更多字符表达，那就是32个bit位啊，如果只表达一个英文字母，8位就足够足够了，剩余的位置都要补0，空占位而已。</p><p>所以UTF-8 出现了。</p><p>UTF-8可以非常灵活根据不同字符，采用1-4个字符去表达，比如我们熟知的：英文1个字符，汉字两个字符，但要知道，有别的语言字符需要3-4个字符才能表达。</p><p>文字字符太单调了，不够生动形象，全球人类都能通过笑和哭的表情来表达信息，如果能有表情就好了，怎么办呢？</p><p>二次元的国都 —— 日本，率先发明了emoji，来解决这个问题，比如：😯😈😎😆☹️</p><p>e表示”絵”，moji表示”文字”。连在一起，就是”絵文字”，是不是很日文？</p><p>流行以后难免要统一起来，那就国际化吧：Unicode开始接纳emoji。所以，对计算机来说：</p><p>emoji就是字符，emoji就是字符，emoji就是字符。</p><p>现在emoji越来越多，都在<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">这里</a>：<a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">http://www.unicode.org/emoji/charts/full-emoji-list.html</a></p><p>将来随着新名词的出现和老词汇的丰富，还会有更多emoji表情出现，所以我们正在经历电脑字符愈来愈多的年代。</p><p>为什么同样的笑脸emoji在不同的平台上长得稍微有些不一样呢？比如微信里的，和电脑里的，或其他语言平台安卓下的？</p><p>因为：Unicode只规定了Emoji在某个01组合位置的含义，并没有规定它的长相。所以假设1000101表示大笑，那不同的平台只要给出符合自己民情的笑脸样式即可。</p><p>话题跑远了，回到技术话题：当百度搜索你好时，看到的请求编码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?wd=%E4%BD%A0%E5%A5%BD</span><br></pre></td></tr></table></figure></p><p>很明显汉字【你好】被编码成了【%E4%BD%A0%E5%A5%BD】，且还有这多%%%。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机供01高低电位表示信息，01也是最小逻辑单元。&lt;/p&gt;
&lt;p&gt;一个字节由8个bit位表示，也就是一个字节最多能表示256个字符（256种组合）&lt;/p&gt;
&lt;p&gt;ASCII码就是这种表示方法，但只用钱7位表达了128个字符，开头都是0，这128个字符包含常见的英文字母大小
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MongoDB备忘</title>
    <link href="http://chayangge.com/2018/09/17/MongoDB%E5%A4%87%E5%BF%98/"/>
    <id>http://chayangge.com/2018/09/17/MongoDB备忘/</id>
    <published>2018-09-17T06:39:30.000Z</published>
    <updated>2018-09-29T09:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：<br><a id="more"></a></p><ul><li>先登录机器</li><li>链接MongoDB：mongo 10.5.XX.XX:端口</li><li>show dbs</li><li>use 某db</li><li>show tables</li><li>db.sometable.find({‘_id’:’XX’});</li><li>db.sometable.update({条件},{$set:{key:value}},{multi:true}));</li></ul><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sometable.find(&#123;&apos;url&apos;:&#123;$regex:/key/i&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&apos;表名&apos;)</span><br></pre></td></tr></table></figure><h3 id="关闭MongoDB"><a href="#关闭MongoDB" class="headerlink" title="关闭MongoDB"></a>关闭MongoDB</h3><ul><li>先退出：mongo –port 8415（只用端口号登录）</li><li>use admin</li><li>db.shutdownServer()</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>cd到MongoDB安装文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f mongod.conf</span><br></pre></td></tr></table></figure><h3 id="复制集"><a href="#复制集" class="headerlink" title="复制集"></a>复制集</h3><p>MongoDB数据库有多个节点时，会包含一个Primary节点和多个Secondary节点，数据先写入Primary节点，其他Secondary再从Primary中同步写入的数据，因此当连接数据库后，光标起始位置会显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:PRIMARY&gt;</span><br></pre></td></tr></table></figure></p><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某某db:SECONDARY&gt;</span><br></pre></td></tr></table></figure></p><p>当要操作Secondary节点时，由于secondary节点默认不可读，会收到一下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;errmsg&quot; : &quot;not master and slaveOk=false&quot;,</span><br><span class="line">&quot;code&quot; : 13435,</span><br><span class="line">&quot;codeName&quot; : &quot;NotMasterNoSlaveOk&quot;</span><br></pre></td></tr></table></figure></p><p>解决办法，执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br></pre></td></tr></table></figure></p><p>但下次连接是依然报错，若想根治，则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.mongorc.js</span><br><span class="line"></span><br><span class="line">增加:rs.slaveOk();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因业务原因，需登录机器手动操作MongoDB，每次操作每次查，现备份一次，方便日后：&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://chayangge.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>TCP三次握手与SYN Flood攻击</title>
    <link href="http://chayangge.com/2018/09/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8ESYN-Flood%E6%94%BB%E5%87%BB/"/>
    <id>http://chayangge.com/2018/09/08/TCP三次握手与SYN-Flood攻击/</id>
    <published>2018-09-08T08:08:07.000Z</published>
    <updated>2018-10-30T02:19:35.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>三次握手大家都耳熟能详了：</p><ul><li>客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应</li><li>服务端收到信号，返回SYN+ACK（Synchronization-Acknowledgement）信号，声明做好接收消息的准备，并要求客户端也要做好接收消息的准备，然后进入SYN_RCVD状态，也就是半开状态，服务端会持续等待客户端再次发起的确认信息，这个等待时间很长，能达到分钟级别。（注意：这里是攻击的核心点）</li><li>客户端收到消息后，再次发送ACK(Acknowledgement)消息给服务端，声明做好了接收数据的准备</li><li>连接成功</li></ul><h3 id="为什么三次？"><a href="#为什么三次？" class="headerlink" title="为什么三次？"></a>为什么三次？</h3><p>因为通信双方要互相告知自己的Sequence Numbers，这个序号将作为后续通讯的数字信号，TCP会议这个序号来拼接数据，以保证数据段的顺序。相当于两人如果发生转账，必须要先知到彼此的账号一样。</p><p>其次，三次是满足一个完整、妥善会话的最小逻辑单元，比如：</p><ul><li>A:我账号是001，求汇款500元？</li><li>B:可以，我的账号002，已向你转账500。</li><li>A:好的，收到！</li></ul><p>中间任何一步的失败都会造成会话的不完整，要么A不能确认B是否转账，要么B不能确认A是否收到汇款。</p><h3 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h3><p>如上所述，B转账后会处于半开放状态，要持续等待两分钟，直到收到A的确认收到汇款消息为止。等待是焦急的，劳神的，是耗费脑细胞的。当成千上万的虚假客户端只发送握手信号SYN，收到服务端信号后，并不再次发起确认信号时，服务端则会占用大量的系统内存来维持等待这些半开放的连接，耗尽系统资源，导致正常的握手请求得不到响应，这就是SYN Flood攻击的原理。</p><h3 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h3><ul><li>缩短SYN Timeout时间</li><li>提高半开状态数量</li><li>SYN cookie：<blockquote><p>服务端收到握手信号SYN，在返回SYN+ACK时对ACK进行加密，加密信息包含原地址、端口、目标地址，总之能标识是谁发来的信息，然后不进入半开放状态，直接释放所以状态，这样省去了维持等待所耗费的系统资源，当收到客户端字再次发起的ACK信号时，计算是否为上个SYN+ACK消息的返回，如果是则直接进入连接状态。</p></blockquote></li><li>Firewalls and Proxies：<blockquote><p>用防火墙作为客户端和服务端的中间代理，客户端先与防火墙建立三次握手，只有在握手成功后，防火墙再与服务端建立握手，然后防火墙在中间代理数据传输。此时服务端收到的都是正常握手请求。</p></blockquote></li></ul><p>参考：<a href="https://www.wikiwand.com/en/SYN_flood#" target="_blank" rel="noopener">https://www.wikiwand.com/en/SYN_flood#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;三次握手大家都耳熟能详了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发起握手信号SYN（Synchronize Sequence Numbers），然后进入 SYN_SEND 状态，等待服务端响应&lt;/li&gt;
&lt;li&gt;服务端收到信号，返回SYN+A
      
    
    </summary>
    
    
      <category term="TCP" scheme="http://chayangge.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Base64</title>
    <link href="http://chayangge.com/2018/08/13/Base64/"/>
    <id>http://chayangge.com/2018/08/13/Base64/</id>
    <published>2018-08-12T16:03:30.000Z</published>
    <updated>2018-08-12T16:46:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。</p><h3 id="为什么会有Base64？"><a href="#为什么会有Base64？" class="headerlink" title="为什么会有Base64？"></a>为什么会有Base64？</h3><p>Base64加密后的信息理论上会比原信息大三分之一左右，数据变大是不利于传输的，那什么优势让它依然被使用呢？</p><p>答案是因为早期的邮件传输协议SMTP只能传输可打印的ASCII码，那不支持传输的ASCII码只能换一种编码方式，用可传输的ASCII码部分来表示信息。</p><h3 id="用了哪些字符码"><a href="#用了哪些字符码" class="headerlink" title="用了哪些字符码"></a>用了哪些字符码</h3><p>虽然名叫base64，但实际用了65个字符，因为尾部用“=”表示结束，首先从0开始，到51位分别为大小写的字母a-z，52至61为数字0-9，另外加两个字符+/，正好64。<br>所以一个标准的base64编码数据就是大小写混合夹杂数字偶尔出现+/，结尾还会有“=”。</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><p>转换规则如下：<br><img src="http://7xprui.com1.z0.glb.clouddn.com/base64.png" alt="转换规则"></p><p>直接看字母的二进制数据，base64把原本的8Bit一组的数据从新按6Bit一组，然后把这新的6位二进制转换成十进制，再从10进制中找到对应的字符，组成了base64的编码。这样，无论什么数据，都能用上述64个字符表达出来，而这64个字符在所有的协议中都能顺利传输。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>base64以增加传输数据变大为代价，换取了传输的兼容性，然后仅仅在肉眼上实现了‘加密’。</p><p>前端接触最多的应用场景是用于表达图片二进制信息，把不是很大的图片用base64标识，直接放在html或css中，省去浏览器再发一个资源请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，Base64不是加密方式，而是一种数据的编码方式，只是在视觉上起到了‘加密’的功能而已。&lt;/p&gt;
&lt;h3 id=&quot;为什么会有Base64？&quot;&gt;&lt;a href=&quot;#为什么会有Base64？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有Base64？&quot;
      
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>天！居然断更了这么久</title>
    <link href="http://chayangge.com/2018/08/12/%E5%A4%A9%EF%BC%81%E5%B1%85%E7%84%B6%E6%96%AD%E6%9B%B4%E4%BA%86%E8%BF%99%E4%B9%88%E4%B9%85/"/>
    <id>http://chayangge.com/2018/08/12/天！居然断更了这么久/</id>
    <published>2018-08-12T06:31:05.000Z</published>
    <updated>2018-08-11T17:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>天！居然断更了这么久，</p><p>换了份工作，</p><p>把博客落下了，</p><p>适应工作节奏后，</p><p>总感觉时间不够用，</p><p>博客就：拖…</p><p>然后，服务器又到期了，</p><p>要不要买服务器呢？买哪家？</p><p>拖…</p><p>终于又买了服务器，</p><p>换了腾讯云，</p><p>可，备案居然要重新审核，</p><p>拖…</p><p>备案终于过了，</p><p>然而，本地博客跑不起来了，</p><p>还得修，</p><p>拖…</p><p>重装了博客、改了配置、再绑域名、装git、装nginx、nginx.config 等一系列操作，</p><p>终于完成了，</p><p>总耗时接近一年！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;天！居然断更了这么久，&lt;/p&gt;
&lt;p&gt;换了份工作，&lt;/p&gt;
&lt;p&gt;把博客落下了，&lt;/p&gt;
&lt;p&gt;适应工作节奏后，&lt;/p&gt;
&lt;p&gt;总感觉时间不够用，&lt;/p&gt;
&lt;p&gt;博客就：拖…&lt;/p&gt;
&lt;p&gt;然后，服务器又到期了，&lt;/p&gt;
&lt;p&gt;要不要买服务器呢？买哪家？&lt;/p&gt;
&lt;p&gt;拖…
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0.1 + 0.2 !== 0.3</title>
    <link href="http://chayangge.com/2018/02/13/0-1-0-2-0-3/"/>
    <id>http://chayangge.com/2018/02/13/0-1-0-2-0-3/</id>
    <published>2018-02-13T08:23:48.000Z</published>
    <updated>2019-02-14T08:24:04.331Z</updated>
    
    <content type="html"><![CDATA[<p>老生常谈的问题了，之前查过一次，模糊记得js、java等语言都存在此问题，后来原因又忘了，最近碰到，再补充一下。</p><a id="more"></a><h3 id="计算机如何用二进制表达小数？"><a href="#计算机如何用二进制表达小数？" class="headerlink" title="计算机如何用二进制表达小数？"></a>计算机如何用二进制表达小数？</h3><blockquote><p>乘2取整，直至小数部分为0，然后把取的整数顺序排列</p></blockquote><p>比如：0.8125:</p><p>0.8125 <em> 2 = 1.625，取1，剩余0.625<br>0.625 </em>2 = 1.25，取1，剩余0.25<br>0.25 <em> 2 = 0.5，取0，剩余0.5<br>0.5 </em> 2 = 1.0，取1，终于剩余0.0<br>顺序排列取的整数得到二进制：1101，所以0.8125的二进制表达就是0.1101</p><p>那6.8125呢？</p><p>补充一下整数转换二进制规则：</p><blockquote><p>除2取余，直到商为0，然后倒着拼接余数</p></blockquote><p>如：6</p><p>6 / 2，得3余0<br>3 / 2，得1余1<br>1 / 2，得0余1<br>倒着拼接余数110即为6的二进制<br>所以综上所述6.8125的二进制位：110.1101</p><h3 id="出现误差的原因"><a href="#出现误差的原因" class="headerlink" title="出现误差的原因"></a>出现误差的原因</h3><p>例子是完美的，但很多数据的运算并不顺利，比如0.1</p><p>0.1 <em> 2 = 0.2 取0剩余0.2<br>0.2 </em> 2 = 0.4 取0剩余0.4<br>0.4 <em> 2 = 0.8 取0剩余0.8<br>0.8 </em> 2 = 1.6 取1剩余0.6<br>0.6 * 2 = 1.2 取1剩余0.2<br>….<br>永远不会剩余0，那就是一个无线循环的数0.0001100110011…（0011保持循环）。</p><p>这种情况：计算机会根据IEEE 754进行裁剪取整，这就是精度缺失的根本原因，至于截取规则，IEEE 754规定如果溢出的第一位是1，那就加1，导致某些数据截取后比真实大那么一点点，0.1恰巧因最后的溢出是1，被进位。</p><p>总之精度缺失的原因来自计算机对无线循环的无奈</p><h3 id="总结、解决方案"><a href="#总结、解决方案" class="headerlink" title="总结、解决方案"></a>总结、解决方案</h3><ul><li>认识到小数是不靠谱的，开发中避免直接此类判断0.1 + 0.2 === 0.3</li><li>toFixed也因此有坑：1.005.toFixed(2)，返回的是 <code>1.00</code> 而不是 <code>1.01</code></li><li>第三方工具：number-precision，bignumber.js，Math.js等，把数据转换成string进行处理，性能差点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老生常谈的问题了，之前查过一次，模糊记得js、java等语言都存在此问题，后来原因又忘了，最近碰到，再补充一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://chayangge.com/2017/08/21/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://chayangge.com/2017/08/21/中间件/</id>
    <published>2017-08-21T03:56:16.000Z</published>
    <updated>2017-09-04T02:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。<br><a id="more"></a><br>业界有句名言：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决<br>“Any problem  in computer science can be solved by anther layer of indirection.”</p></blockquote><p>仔细想一下很多问题都是通过添加独立的层的概念来解决的，包括一些已经作为常识的知识，比如：互联网层的划分，从底层的物理层，到上层的应用层，彼此层之间相互独立，各司其职，以后再有什么升级或改动，保证原有层不变的基础上，添加一个层承上启下，即可。比如HTTPS就是在HTTP的基础上多了一层加密层。</p><p>而中间件的概念貌似也是如此。一个中间件就是一个功能层，相互独立，各司其职。</p><p>以express中间件为例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listen 3000...'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(middleware1);</span><br><span class="line">app.use(middleware2);</span><br><span class="line">app.use(middleware3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是1，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是2，out"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params">req, res, next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3"</span>);</span><br><span class="line">next();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我是3，out"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>app.use方法用来接收中间件1、2、3，其执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">listen 3000...</span><br><span class="line">我是1</span><br><span class="line">我是2</span><br><span class="line">我是3</span><br><span class="line">我是3，out</span><br><span class="line">我是2，out</span><br><span class="line">我是1，out</span><br></pre></td></tr></table></figure></p><p>为什么遇到next后就直接跳转，等所有next执行完毕才回溯执行各自next后面的代码呢？app.use内部又是怎么回事呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从结果可以看出，多个中间件的执行顺序是按栈结构执行的，首先遇到next跳转到下一个中间件执行，直到最内部的中间值执行完毕后，才执行最内部中间件next后面的代码，执行完后才返回上一层执行上一层中间件next后面的代码，像极了洋葱图。</p><p>而在代码层面上，每当调用app.use添加中间件时，其实内部维护了一个数组，把这些追加的中间件push进去，然后反方向执行，先执行数组最末端的中间件，直到第一个push进去的中间件，这样就实现了上述中间件调用效果。demo：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中间件，对新手来说又是个不明觉厉的词汇，简单地说，几乎所有的应用都是一个服务器收发的过程，客户端通过http发送请求，服务器收到请求后给出响应，这是整个互联网的运作方式，而中间件，顾名思义，就是在收发之间做逻辑处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>关于cookie</title>
    <link href="http://chayangge.com/2017/07/26/%E5%85%B3%E4%BA%8Ecookie/"/>
    <id>http://chayangge.com/2017/07/26/关于cookie/</id>
    <published>2017-07-26T11:02:08.000Z</published>
    <updated>2017-08-05T07:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。<br><a id="more"></a><br>大家都知道http是无状态的，也就是说在一个没有cookie技术的纯请求中，服务器分不清谁请求了，以及这次请求和上次什么关系，这导致无法标识是否登录，等等所有常规功能。如果说互联网是个随进随出的商场的话，那么cookie则相当于每个请求的帽子，这个帽子标识了每个请求的身份，且这个帽子服务器可以种植，客户端（浏览器）也可以种植。</p><h2 id="cookie的样子"><a href="#cookie的样子" class="headerlink" title="cookie的样子"></a>cookie的样子</h2><p>cookie是一段文本，之所以在浏览器中看到呈现key、value的形式，是因为保存的这段文本中是以“=”和“;”隔开的，浏览器调试工具下输入<code>documen.cookie</code>就能看到。</p><h2 id="cookie的种植"><a href="#cookie的种植" class="headerlink" title="cookie的种植"></a>cookie的种植</h2><p>上文说道，cookie的种植有两种方式，服务端和客户端，服务器返回请求内容的时候用Set-Cookie在客户端下种植cookie，也可以用浏览器的方式js手动种植，比如：documen.cookie = “key = value”;一旦cookie种植后，因同源策略，在同源下的所有请求都会带上cookie，从浏览器的开发者工具中查看：</p><p>有一点需要注意，浏览器js有个属相不能设置，那就是<code>HttpOnly 属性</code>，服务端设置HttpOnly属性后，在浏览器通过documen.cookie则不能读取cookie，相对来说增加了一层安全性，提高了破解难度，但也不是万能的。</p><h2 id="cookie存在哪？"><a href="#cookie存在哪？" class="headerlink" title="cookie存在哪？"></a>cookie存在哪？</h2><p>cookie是一段文本，并存在本地，那具体在哪里呢？<br>chrome是放在：<code>~/Library/Application\ Support/Google/Chrome/Default/Cookies</code>目录下，火狐则放在<code>~/Library/Application\ Support/Firefox/Profiles/t22mmcz1.default/cookies.sqlite</code>目录下，这些都是肉眼可看到的实实在在的文本，没什么神秘感。</p><h2 id="cookie常用的属性"><a href="#cookie常用的属性" class="headerlink" title="cookie常用的属性"></a>cookie常用的属性</h2><ul><li>expires：设置cookie的过期时间</li><li>domain：指定 cookie 将要被发送至哪个或哪些域中</li><li>path：指定了请求的资源 URL 中必须存在指定的路径时，才会带相应cookie</li><li>secure：是否要求https</li><li>HttpOnly：告知浏览器该 cookie 不能通过 JavaScript 的document.cookie访问</li></ul><h2 id="cookie的容量"><a href="#cookie的容量" class="headerlink" title="cookie的容量"></a>cookie的容量</h2><p>既然cookie能携带信息，那到底能携带多少呢？官方给出的标准是4096，但实际情况则要看浏览器了，重要的是每人会愿意在cookie上携带大量信息，因为cookie每次请求都会默认带上，如果很大，则增加了请求开销。</p><h2 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h2><p>ajax请求有同源策略，cookie也要，一个cookie又要起对应生效的域名地址，仅在本域名下才能生效，</p><h2 id="同源策略导致的问题"><a href="#同源策略导致的问题" class="headerlink" title="同源策略导致的问题"></a>同源策略导致的问题</h2><p>印绶同源策略，导致cookie不能共享，但一个大公司下的各个平台往往需要靠二级域名来区分，但对用户来说，一个账号要登录所有平台，这就导致一个问题，每个二级域名的子系统下都要登录一次？那用户岂不要疯掉，比如，你登录的新浪邮箱，当你进去微博时，提示你请登录，当你进入新浪博客时再提醒你登录。。。。，那该怎么解决该问题呢？</p><h2 id="单点登录-SSO（Single-Sign-On）"><a href="#单点登录-SSO（Single-Sign-On）" class="headerlink" title="单点登录 SSO（Single Sign On）"></a>单点登录 SSO（Single Sign On）</h2><p>单店登录解决了上述问题，用户只需在一个子系统处登录，则全站任何子系统都不用再重新登录，具体原理是：建立独立的认证中心SSO server，认证中心独立于各个站点，用来统一验证并管理登录，具体不走如下：</p><ul><li>用户在站点A输入用户名和密码点击登录 站点A将用户名和密码转发给认证中心进行认证，认证中心返回Token</li><li>站点A将当前登录用户和Token存入Session(或Cookie) 在站点A上点击连接访问站点B，通过URL参数方式，将Token带给站点B </li><li>站点B将Token转交到认证中心，认证正确，返回当前用户名。 站点B将当前登录用户和Token存入Session(或Cookie)</li><li>完成登录流程</li></ul><h2 id="cookie的安全问题"><a href="#cookie的安全问题" class="headerlink" title="cookie的安全问题"></a>cookie的安全问题</h2><p>既然在请求中用cookie标志了用户，那么如果劫持获取了cookie，就能伪造真实用户做出假冒行为，常见的攻击比如：<br>CSRF:跨站请求伪造(英语:Cross-site request forgery)，通常缩写为 CSRF 或者 XSRF， 是 种冒充 户发起请求(在 户 知情的情况下),完成 些违背 户意愿的请求(如恶意发 帖，删帖，改密码，发邮件等)。</p><p>之前文章中介绍的爬虫，在爬取需要登录的页面信息时，其实也是借用别的cookie发送的请求，和CSRF的原理是一样的。</p><p>注明的Apache服务器曾经就有一个有关cookie的漏洞，具体如下：</p><blockquote><p>Apache服务器2.2.0-2.2.21版本存在一个漏洞（CVE-2012-0053），攻击者可通过给网站植入超大的Cookie，使得HTTP头超过apache的LimitRequestFieldSize（最大请求长度）4192字节，apache便会返回400错误，状态页中就包含了http-only保护的cookies。</p></blockquote><p>简单的说就是：Apache服务器咋就cookie过多时，返回的报错信息中包含了http-only。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好奇怪，cookie每人都知道，但在面试中正能回答个一二三的还真不多，能问倒一大片，下面是有关cookie的知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://chayangge.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>简单实现双向数据绑定</title>
    <link href="http://chayangge.com/2017/04/24/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>http://chayangge.com/2017/04/24/简单实现双向数据绑定/</id>
    <published>2017-04-24T12:26:18.000Z</published>
    <updated>2017-04-25T02:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。<br><a id="more"></a><br>实现双向绑定的方法有三种：</p><ul><li>发布/订阅模式，比如 backbone</li><li>脏检查，比如angular，（现在angular啥样就不知道了）</li><li>以Vue为代表的数据劫持 （基于Object.defineProperty()，缺陷：IE8不支持）</li></ul><p>这里就用Object.defineProperty()来实现一个小demo，哪怕IE8不支持，但也会消亡，对此不用过于care。<br>先看html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind</span>=<span class="string">"value"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imgsrc"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"sayHi"</span>&gt;</span>sayHi()<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先要解析html里id为app的节点内容，有v-model，v-bind，v-on，解析这些命令，得出相应的操作，解析这些节点属性用到最基本的DOM属性获取操作：childNodes、attributes。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  模板解析</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>);</span><br><span class="line">    <span class="keyword">var</span> nodes = app.childNodes;</span><br><span class="line">    [].slice.call(nodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">        search(ele); <span class="comment">// 这里要挨个遍历并解析app里的节点</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模板就这样，机上绑定数据，就要有相关数据和函数供模板绑定，我们使用Vue初始化实例的时候都要有data，methods等参数，这里同样也需要data和绑定函数methods，为了方便，这里就定义为$data和funs：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funs = &#123;</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hi..."</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    test:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"test..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $data = &#123;</span><br><span class="line">    imgsrc:<span class="string">"https://img6.bdstatic.com/img/image/smallpic/h1.jpg"</span>,</span><br><span class="line">    value:<span class="string">"123abc"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎样解析模板呢？命令提取而已，无非先去除DOM上的所有属性，从中挑出有价值的，比如以v-打头的，挑出后把带有v-打头属性的节点替换一下文本内容或添加相应的监听函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> atts = node.attributes;</span><br><span class="line">    <span class="keyword">if</span>(atts)&#123;</span><br><span class="line">        [].slice.call(atts).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name,</span><br><span class="line">                attrValue = attr.value,</span><br><span class="line">                active = attrName.substring(<span class="number">2</span>),</span><br><span class="line">                activeName = attrName.split(<span class="string">":"</span>)[<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(attrName.indexOf(<span class="string">"v-"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dataMap[attrValue])&#123;</span><br><span class="line">                dataMap[attrValue].push(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(attr.name.indexOf(<span class="string">"on"</span>)!== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.addEventListener(activeName,funs[attr.value],<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析 bind  v-bind:src="XXXX"</span></span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"bind"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(activeName)&#123;</span><br><span class="line">                    node.setAttribute(activeName,$data[attrValue]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node.innerHTML = $data[attrValue];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(active.indexOf(<span class="string">"model"</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">                node.value = $data[attrValue];</span><br><span class="line">                <span class="comment">// 这是input标签双向绑定的重点</span></span><br><span class="line">                node.addEventListener(<span class="string">"input"</span>,bindInput,<span class="literal">false</span>);                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">bindInput</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">                node.value = $data[attrValue] = event.target.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好，到这里已经完成了对模板的初始化解析，该替换的替换，该监听的事件函数也都能添加了，但这是静态的，也就是说，只能第一次绑定data，data变动怎么办呢？这里就要用到Object.defineProperty()，该属性是ES5中的，是个好东西，没有它就没有Vue，不熟悉的可以了解一下，这里不做介绍。总之数据data变动时，会触发set操作，因此在set发生时，说明数据更新了，即可更新模板，原理就这么简单，但我们首先要做的是实现对$data的每一项进行监听，遍历一遍即可，碰到对象则递归再遍历：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    observe(val); <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(val === newValue)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"老的："</span>, val, <span class="string">"变新的：--》"</span>, newValue);</span><br><span class="line">            val = newValue;</span><br><span class="line">            init(); <span class="comment">// 更新模板</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候文本框和data及p元素实现了双向数据绑定，且按钮也添加了点击事件sayHi能成功绑定执行。</p><p>至此，一个基于数据劫持的双向数据绑定demo已经完成，核心就是通过Object.defineProperty监听数据的变动，有变动则刷新模板，而模板里解析指令，并执行相应的指令或函数绑定。</p><p>但本demo运行时查看源码依然能看到写在标签元素上的指令，而vue模板源码却看不到，为什么？答案是因为vue为了增加性能，把模板节点转换成成文档碎片fragment，进行遍历加工替换等操作后，再把处理后的结果插入id为app的根DOM中，这样总体上只有一次DOM的append操作，而DOM操作是性能的杀手，vue以此提升性能，而本demo没考虑性能优化，是直接遍历替换DOM的，所以demo有很多不足，目的只为说明数据劫持实现双向数据绑定的原理，有空会再写一篇详细的作为补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于MVVM的双向数据绑定是这两年的技术热点，各种新框架层出不穷，前端页面的很多动作再也不用依赖jQuery的面条式操作DOM节点了，这里就简单实现一个双向数据绑定，消除神秘感。&lt;br&gt;
    
    </summary>
    
    
      <category term="mvvm" scheme="http://chayangge.com/tags/mvvm/"/>
    
  </entry>
  
  <entry>
    <title>公众号爬虫node版</title>
    <link href="http://chayangge.com/2017/03/28/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%88%AC%E8%99%ABnode%E7%89%88/"/>
    <id>http://chayangge.com/2017/03/28/公众号爬虫node版/</id>
    <published>2017-03-28T12:53:23.000Z</published>
    <updated>2017-03-29T01:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前用<a href="http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/">python实现</a>了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是<a href="https://github.com/chayangge/node-crawler" target="_blank" rel="noopener">源码</a>，数据来源<a href="http://chuansong.me/" target="_blank" rel="noopener">在这里</a>。<br><a id="more"></a></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>clone并安装：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/chayangge/node-crawler.git</span></span><br><span class="line">cd node-crawler</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app</span><br></pre></td></tr></table></figure></p><p>会在项目根目录下创建以微信ID命名的文件夹，里面存放抓取后的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用&lt;a href=&quot;http://chayangge.com/2017/03/22/%E7%94%A8python%E6%8A%93%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/&quot;&gt;python实现&lt;/a&gt;了一盒简单爬虫，这次还用node实现，体会两者的差异。原理都一样，代码不到100行，这里是&lt;a href=&quot;https://github.com/chayangge/node-crawler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码&lt;/a&gt;，数据来源&lt;a href=&quot;http://chuansong.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在这里&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://chayangge.com/tags/node/"/>
    
  </entry>
  
</feed>
